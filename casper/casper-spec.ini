; casper commit: master b2a1189
; vyper  commit: master 7b1e018 vyper -f bytecode_runtime simple_casper.v.py
; k      commit: casper 5c25763980fd52c92c637395a7fd64e561569512
; kevm   commit: master 777c67828c5b26f39112bad709e9a65a337f7de5

[root]
comment:
k: (#execute => #halt) ~> _
callStack: _
wordStack: .WordStack => _
localMem: .Map => _
pc: 0 => _
gas: 1000000 => _
memoryUsed: 0 => _
callDepth: CD
log: _
refund: _
coinbase: _
activeAccounts: SetItem(CASPER_ACCT_ID) _:Set
casperBalance: CASPER_BAL
accounts:
requires:
    andBool #range(0 <= CD < 1024)
    andBool #rangeUInt(256, CASPER_BAL)
ensures:
attribute:

[recommended_source_epoch]
output: _ => #asByteStackInWidth(EXPECTED_SOURCE_EPOCH, 32)
statusCode: _ => EVMC_SUCCESS
callData: #abiCallData("recommended_source_epoch", .TypedArgs)
callValue: 0
storage:
    // self.expected_source_epoch : int128
    (#hashedLocation({COMPILER}, {EXPECTED_SOURCE_EPOCH}, .IntList) |-> EXPECTED_SOURCE_EPOCH)
    _:Map
+requires:
    // Range
    andBool #rangeSInt(128, EXPECTED_SOURCE_EPOCH)
    // Invariant
    andBool EXPECTED_SOURCE_EPOCH >=Int 0

[recommended_target_hash]
gas: GCAP => _
callData: #abiCallData("recommended_target_hash", .TypedArgs)
callValue: 0
storage:
    // self.current_epoch
    (#hashedLocation({COMPILER}, {CURRENT_EPOCH}, .IntList) |-> CURRENT_EPOCH)
    // self.EPOCH_LENGTH
    (#hashedLocation({COMPILER}, {EPOCH_LENGTH}, .IntList) |-> EPOCH_LENGTH)
    _:Map
+requires:
    // Range
    andBool #rangeSInt(128, CURRENT_EPOCH)
    andBool #rangeSInt(128, EPOCH_LENGTH)
    // Invariant
    andBool CURRENT_EPOCH >Int 0
    andBool EPOCH_LENGTH >Int 0
    // Gas
    andBool GCAP >=Int 893

[recommended_target_hash-success]
output: _ => #asByteStackInWidth(#recommendedBlockHash(BLOCK_HASHES, BLOCK_NUM, CURRENT_EPOCH, EPOCH_LENGTH), 32)
statusCode: _ => EVMC_SUCCESS
gas: GCAP => GCAP -Int 893
+requires:
    // Overflow check
    andBool (CURRENT_EPOCH *Int EPOCH_LENGTH) <=Int maxSInt128
    andBool #range(BLOCK_NUM -Int 256 <= #expectedBlockNumber(CURRENT_EPOCH, EPOCH_LENGTH) < BLOCK_NUM)

[recommended_target_hash-failure]
output: _ => _

[recommended_target_hash-failure-11]
statusCode: _ => EVMC_REVERT
+requires:
    andBool (CURRENT_EPOCH *Int EPOCH_LENGTH) <=Int maxSInt128
    andBool #expectedBlockNumber(CURRENT_EPOCH, EPOCH_LENGTH) >=Int BLOCK_NUM

[recommended_target_hash-failure-12]
statusCode: _ => EVMC_REVERT
+requires:
    andBool (CURRENT_EPOCH *Int EPOCH_LENGTH) <=Int maxSInt128
    andBool #expectedBlockNumber(CURRENT_EPOCH, EPOCH_LENGTH) <Int BLOCK_NUM -Int 256

[recommended_target_hash-failure-2]
statusCode: _ => EVMC_BAD_JUMP_DESTINATION
+requires:
    andBool (CURRENT_EPOCH *Int EPOCH_LENGTH) >Int maxSInt128

[deposit_exists]
callData: #abiCallData("deposit_exists", .TypedArgs)
callValue: 0

[deposit_exists-success]
statusCode: _ => EVMC_SUCCESS
storage:
    // self.total_curdyn_deposits : decimal
    (#hashedLocation({COMPILER}, {TOTAL_CURDYN_DEPOSITS}, .IntList)  |-> TOTAL_CURDYN_DEPOSITS)
    // self.total_prevdyn_deposits : decimal
    (#hashedLocation({COMPILER}, {TOTAL_PREVDYN_DEPOSITS}, .IntList)  |-> TOTAL_PREVDYN_DEPOSITS)
    _:Map
+requires:
    // Range
    andBool #rangeSFixed(128, 10, TOTAL_CURDYN_DEPOSITS)
    andBool #rangeSFixed(128, 10, TOTAL_PREVDYN_DEPOSITS)
    // Invariant
    andBool TOTAL_CURDYN_DEPOSITS >=Int 0
    andBool TOTAL_PREVDYN_DEPOSITS >=Int 0
    //
    andBool CALLER_ID ==Int CASPER_ACCT_ID

[deposit_exists-failure]
output: _ => _
statusCode: _ => EVMC_INVALID
storage:
    _:Map
+requires:
    andBool CALLER_ID =/=Int CASPER_ACCT_ID

[deposit_exists-success-true]
output: _ => #asByteStackInWidth(1, 32)
+requires:
    andBool TOTAL_CURDYN_DEPOSITS  >Int 0
    andBool TOTAL_PREVDYN_DEPOSITS >Int 0

[deposit_exists-success-false-1]
output: _ => #asByteStackInWidth(0, 32)
+requires:
    andBool TOTAL_CURDYN_DEPOSITS  <=Int 0

[deposit_exists-success-false-2]
output: _ => #asByteStackInWidth(0, 32)
+requires:
    andBool TOTAL_CURDYN_DEPOSITS  >Int  0
    andBool TOTAL_PREVDYN_DEPOSITS <=Int 0


;  def main_hash_voted_frac() -> decimal:
;    return min(self.votes[self.current_epoch].cur_dyn_votes[self.expected_source_epoch] / self.total_curdyn_deposits,
;               self.votes[self.current_epoch].prev_dyn_votes[self.expected_source_epoch] / self.total_prevdyn_deposits)
;    Possible cases:
;        1. RESULT_1 <=Int RESULT_2,
;        2. RESULT_1 >Int RESULT_2,
;        3. one of {TOTAL_CURDYN_DEPOSITS_VAL, TOTAL_PREVDYN_DEPOSITS_VAL} is 0.
;
[main_hash_voted_frac]
output: _ => _
memoryUsed: 0 => _
callDepth: CD
callStack: _
callData: #abiCallData("main_hash_voted_frac", .TypedArgs)
callValue: 0
wordStack: .WordStack => _
localMem: .Map => _:Map
pc: 0 => _
gas: 100000 => _
log: _
refund: _
coinbase: _
activeAccounts: _
casperBalance: _
storage:
    (#hashedLocation({COMPILER}, {CURRENT_EPOCH}, .IntList)          |-> CURRENT_EPOCH_VAL)
    (#hashedLocation({COMPILER}, {EXPECTED_SOURCE_EPOCH}, .IntList)  |-> EXPECTED_SOURCE_EPOCH_VAL)
    (#hashedLocation({COMPILER}, {VOTES}, CURRENT_EPOCH_VAL {CUR_DYN_VOTES} EXPECTED_SOURCE_EPOCH_VAL) |-> CUR_DYN_VOTES_VAL)
    (#hashedLocation({COMPILER}, {VOTES}, CURRENT_EPOCH_VAL {PREV_DYN_VOTES} EXPECTED_SOURCE_EPOCH_VAL) |-> PREV_DYN_VOTES_VAL)
    (#hashedLocation({COMPILER}, {TOTAL_CURDYN_DEPOSITS}, .IntList)  |-> TOTAL_CURDYN_DEPOSITS_VAL)
    (#hashedLocation({COMPILER}, {TOTAL_PREVDYN_DEPOSITS}, .IntList)  |-> TOTAL_PREVDYN_DEPOSITS_VAL)
    _:Map
accounts:
requires:
    andBool #rangeSInt(128, CURRENT_EPOCH_VAL)
    andBool #rangeSInt(128, EXPECTED_SOURCE_EPOCH_VAL)
    andBool #rangeSFixed(128, 10, CUR_DYN_VOTES_VAL)
    andBool #rangeSFixed(128, 10, PREV_DYN_VOTES_VAL)
    andBool #rangeSFixed(128, 10, TOTAL_CURDYN_DEPOSITS_VAL)
    andBool #rangeSFixed(128, 10, TOTAL_PREVDYN_DEPOSITS_VAL)
    andBool #range(0 <= CD < 1024)

    andBool CURRENT_EPOCH_VAL >=Int 0
    andBool EXPECTED_SOURCE_EPOCH_VAL >=Int 0
    andBool CUR_DYN_VOTES_VAL >=Int 0
    andBool PREV_DYN_VOTES_VAL >=Int 0
    andBool TOTAL_CURDYN_DEPOSITS_VAL >=Int 0
    andBool TOTAL_PREVDYN_DEPOSITS_VAL >=Int 0

    /*votes in a dinasty will always be just a fraction of total deposits*/
    andBool CUR_DYN_VOTES_VAL <=Int TOTAL_CURDYN_DEPOSITS_VAL
    andBool PREV_DYN_VOTES_VAL <=Int TOTAL_PREVDYN_DEPOSITS_VAL
ensures:
attribute:

[main_hash_voted_frac-success-1]
k: (#execute => #halt) ~> _
statusCode: _ => EVMC_SUCCESS
output: _ => #asByteStackInWidth(RESULT_1, 32)
+requires:
    andBool TOTAL_CURDYN_DEPOSITS_VAL =/=Int 0
    andBool TOTAL_PREVDYN_DEPOSITS_VAL =/=Int 0
    andBool RESULT_1 ==Int (CUR_DYN_VOTES_VAL *Int VYPER_DEC_MULTIPLIER /Int TOTAL_CURDYN_DEPOSITS_VAL)
    andBool RESULT_2 ==Int (PREV_DYN_VOTES_VAL *Int VYPER_DEC_MULTIPLIER /Int TOTAL_PREVDYN_DEPOSITS_VAL)
    andBool RESULT_1 <=Int RESULT_2
ensures:
    ensures 0 <=Int RESULT_1 andBool RESULT_1 <=Int VYPER_DEC_MULTIPLIER

[main_hash_voted_frac-success-2]
k: (#execute => #halt) ~> _
statusCode: _ => EVMC_SUCCESS
output: _ => #asByteStackInWidth(RESULT_2, 32)
+requires:
    andBool TOTAL_CURDYN_DEPOSITS_VAL =/=Int 0
    andBool TOTAL_PREVDYN_DEPOSITS_VAL =/=Int 0
    andBool RESULT_1 ==Int (CUR_DYN_VOTES_VAL *Int VYPER_DEC_MULTIPLIER /Int TOTAL_CURDYN_DEPOSITS_VAL)
    andBool RESULT_2 ==Int (PREV_DYN_VOTES_VAL *Int VYPER_DEC_MULTIPLIER /Int TOTAL_PREVDYN_DEPOSITS_VAL)
    andBool RESULT_1 >Int RESULT_2
ensures:
    ensures 0 <=Int RESULT_2 andBool RESULT_2 <=Int VYPER_DEC_MULTIPLIER

[main_hash_voted_frac-failure]
k: (#execute => #halt) ~> _
statusCode: _ => EVMC_REVERT
+requires:
    andBool (TOTAL_CURDYN_DEPOSITS_VAL ==Int 0 orBool TOTAL_PREVDYN_DEPOSITS_VAL ==Int 0)

;def total_curdyn_deposits_scaled() -> wei_value:
;    return floor(self.total_curdyn_deposits * self.deposit_scale_factor[self.current_epoch])
[total_curdyn_deposits_scaled]
comment:
k: (#execute => #halt) ~> _
output: _ => _
callStack: _
callData: #abiCallData("total_curdyn_deposits_scaled", .TypedArgs)
callValue: 0
wordStack: .WordStack => _
localMem: .Map => _
pc: 0 => _
gas: 100000 => _
memoryUsed: 0 => _
callDepth: CD
log: _
refund: _
coinbase: _
activeAccounts: _
casperBalance: _
storage:
    // self.total_curdyn_deposits : decimal
    (#hashedLocation({COMPILER}, {TOTAL_CURDYN_DEPOSITS}, .IntList)  |-> TOTAL_CURDYN_DEPOSITS)
    // self.current_epoch : int128
    (#hashedLocation({COMPILER}, {CURRENT_EPOCH}, .IntList) |-> CURRENT_EPOCH)
    //self.deposit_scale_factor[self.current_epoch] : decimal
    (#hashedLocation({COMPILER}, {DEPOSIT_SCALE_FACTOR}, CURRENT_EPOCH) |-> CUR_EPOCH_SCALE_FACTOR)
    _:Map
accounts:
requires:
    andBool #rangeSFixed(128, 10, TOTAL_CURDYN_DEPOSITS)
    andBool #rangeSInt(128, CURRENT_EPOCH)
    andBool #rangeSFixed(128, 10, CUR_EPOCH_SCALE_FACTOR)
    andBool #range(0 <= CD < 1024)

    andBool TOTAL_CURDYN_DEPOSITS   >=Int 0
    andBool CURRENT_EPOCH           >=Int 0
    andBool CUR_EPOCH_SCALE_FACTOR   >Int 0
attribute:
ensures:

[total_curdyn_deposits_scaled-success]
output: _ => #asByteStackInWidth(RESULT, 32)
statusCode: _ => EVMC_SUCCESS
+requires:
    andBool TOTAL_CURDYN_DEPOSITS *Int CUR_EPOCH_SCALE_FACTOR               <=Int maxSInt256
    andBool DECIMAL_RESULT ==Int TOTAL_CURDYN_DEPOSITS *Int CUR_EPOCH_SCALE_FACTOR /Int VYPER_DEC_MULTIPLIER
    andBool DECIMAL_RESULT <=Int maxDecimal
    andBool RESULT ==Int DECIMAL_RESULT /Int VYPER_DEC_MULTIPLIER
ensures:
    ensures #range(0 <= RESULT <= maxSInt128)

[total_curdyn_deposits_scaled-failure-1]
statusCode: _ => EVMC_BAD_JUMP_DESTINATION
+requires:
    andBool TOTAL_CURDYN_DEPOSITS *Int CUR_EPOCH_SCALE_FACTOR               <=Int maxSInt256
    andBool DECIMAL_RESULT ==Int TOTAL_CURDYN_DEPOSITS *Int CUR_EPOCH_SCALE_FACTOR /Int VYPER_DEC_MULTIPLIER
    andBool DECIMAL_RESULT >Int maxDecimal

[total_curdyn_deposits_scaled-failure-21]
statusCode: _ => EVMC_REVERT
+requires:
    andBool TOTAL_CURDYN_DEPOSITS *Int CUR_EPOCH_SCALE_FACTOR               >Int maxSInt256

    //does not work because chop() is not evaluated further when it has symbolic arguments
    /*andBool #range(0 <= (TOTAL_CURDYN_DEPOSITS *Int CUR_EPOCH_SCALE_FACTOR) modInt pow256   <= maxSInt256)*/

    andBool #range(0 <= chop(TOTAL_CURDYN_DEPOSITS *Int CUR_EPOCH_SCALE_FACTOR)             <= maxSInt256)

[total_curdyn_deposits_scaled-failure-22]
statusCode: _ => EVMC_REVERT
+requires:
    andBool TOTAL_CURDYN_DEPOSITS *Int CUR_EPOCH_SCALE_FACTOR               >Int maxSInt256
    andBool #range(maxSInt256 <  chop(TOTAL_CURDYN_DEPOSITS *Int CUR_EPOCH_SCALE_FACTOR)            <= maxUInt256)

;def total_prevdyn_deposits_scaled() -> wei_value:
;    return floor(self.total_prevdyn_deposits * self.deposit_scale_factor[self.current_epoch])
[total_prevdyn_deposits_scaled]
comment:
k: (#execute => #halt) ~> _
output: _ => _
callStack: _
callData: #abiCallData("total_prevdyn_deposits_scaled", .TypedArgs)
callValue: 0
wordStack: .WordStack => _
localMem: .Map => _
pc: 0 => _
gas: 100000 => _
memoryUsed: 0 => _
callDepth: CD
log: _
refund: _
coinbase: _
activeAccounts: _
casperBalance: _
storage:
    // self.total_prevdyn_deposits : decimal
    (#hashedLocation({COMPILER}, {TOTAL_PREVDYN_DEPOSITS}, .IntList)  |-> TOTAL_PREVDYN_DEPOSITS)
    // self.current_epoch : int128
    (#hashedLocation({COMPILER}, {CURRENT_EPOCH}, .IntList) |-> CURRENT_EPOCH)
    //self.deposit_scale_factor[self.current_epoch] : decimal
    (#hashedLocation({COMPILER}, {DEPOSIT_SCALE_FACTOR}, CURRENT_EPOCH) |-> CUR_EPOCH_SCALE_FACTOR)
    _:Map
accounts:
requires:
    andBool #rangeSFixed(128, 10, TOTAL_PREVDYN_DEPOSITS)
    andBool #rangeSInt(128, CURRENT_EPOCH)
    andBool #rangeSFixed(128, 10, CUR_EPOCH_SCALE_FACTOR)
    andBool #range(0 <= CD < 1024)

    andBool TOTAL_PREVDYN_DEPOSITS   >=Int 0
    andBool CURRENT_EPOCH           >=Int 0
    andBool CUR_EPOCH_SCALE_FACTOR   >Int 0
attribute:
ensures:

[total_prevdyn_deposits_scaled-success]
output: _ => #asByteStackInWidth(RESULT, 32)
statusCode: _ => EVMC_SUCCESS
+requires:
    andBool TOTAL_PREVDYN_DEPOSITS *Int CUR_EPOCH_SCALE_FACTOR               <=Int maxSInt256
    andBool DECIMAL_RESULT ==Int TOTAL_PREVDYN_DEPOSITS *Int CUR_EPOCH_SCALE_FACTOR /Int VYPER_DEC_MULTIPLIER
    andBool DECIMAL_RESULT <=Int maxDecimal
    andBool RESULT ==Int DECIMAL_RESULT /Int VYPER_DEC_MULTIPLIER
ensures:
    ensures #range(0 <= RESULT <= maxSInt128)

[total_prevdyn_deposits_scaled-failure-1]
statusCode: _ => EVMC_BAD_JUMP_DESTINATION
+requires:
    andBool TOTAL_PREVDYN_DEPOSITS *Int CUR_EPOCH_SCALE_FACTOR               <=Int maxSInt256
    andBool DECIMAL_RESULT ==Int TOTAL_PREVDYN_DEPOSITS *Int CUR_EPOCH_SCALE_FACTOR /Int VYPER_DEC_MULTIPLIER
    andBool DECIMAL_RESULT >Int maxDecimal

[total_prevdyn_deposits_scaled-failure-21]
statusCode: _ => EVMC_REVERT
+requires:
    andBool TOTAL_PREVDYN_DEPOSITS *Int CUR_EPOCH_SCALE_FACTOR               >Int maxSInt256
    andBool #range(0 <= chop(TOTAL_PREVDYN_DEPOSITS *Int CUR_EPOCH_SCALE_FACTOR)             <= maxSInt256)

[total_prevdyn_deposits_scaled-failure-22]
statusCode: _ => EVMC_REVERT
+requires:
    andBool TOTAL_PREVDYN_DEPOSITS *Int CUR_EPOCH_SCALE_FACTOR               >Int maxSInt256
    andBool #range(maxSInt256 <  chop(TOTAL_PREVDYN_DEPOSITS *Int CUR_EPOCH_SCALE_FACTOR)            <= maxUInt256)

;def deposit_size(validator_index: int128) -> int128(wei):
;    return floor(self.validators[validator_index].deposit * self.deposit_scale_factor[self.current_epoch])
[deposit_size]
comment:
k: (#execute => #halt) ~> _
output: _ => _
callStack: _
callData: #abiCallData("deposit_size", #int128(VALIDATOR_INDEX))
callValue: 0
wordStack: .WordStack => _
localMem: .Map => _
pc: 0 => _
gas: 100000 => _
memoryUsed: 0 => _
callDepth: CD
log: _
refund: _
coinbase: _
activeAccounts: _
casperBalance: _
storage:
    // self.validators[validator_index].deposit : decimal
    (#hashedLocation({COMPILER}, {VALIDATORS}, VALIDATOR_INDEX {DEPOSIT}) |-> VALIDATOR_DEPOSIT)
    // self.current_epoch : int128
    (#hashedLocation({COMPILER}, {CURRENT_EPOCH}, .IntList) |-> CURRENT_EPOCH)
    //self.deposit_scale_factor[self.current_epoch] : decimal
    (#hashedLocation({COMPILER}, {DEPOSIT_SCALE_FACTOR}, CURRENT_EPOCH) |-> CUR_EPOCH_SCALE_FACTOR)
    _:Map
accounts:
requires:
    andBool #rangeSInt(128, VALIDATOR_INDEX)
    andBool #rangeSFixed(128, 10, VALIDATOR_DEPOSIT)
    andBool #rangeSInt(128, CURRENT_EPOCH)
    andBool #rangeSFixed(128, 10, CUR_EPOCH_SCALE_FACTOR)
    andBool #range(0 <= CD < 1024)

    andBool VALIDATOR_INDEX         >=Int 0
    andBool VALIDATOR_DEPOSIT       >=Int 0
    andBool CURRENT_EPOCH           >=Int 0
    andBool CUR_EPOCH_SCALE_FACTOR   >Int 0
attribute:
ensures:

[deposit_size-success]
output: _ => #asByteStackInWidth(RESULT, 32)
statusCode: _ => EVMC_SUCCESS
+requires:
    andBool VALIDATOR_DEPOSIT *Int CUR_EPOCH_SCALE_FACTOR               <=Int maxSInt256
    andBool DECIMAL_RESULT ==Int VALIDATOR_DEPOSIT *Int CUR_EPOCH_SCALE_FACTOR /Int VYPER_DEC_MULTIPLIER
    andBool DECIMAL_RESULT <=Int maxDecimal
    andBool RESULT ==Int DECIMAL_RESULT /Int VYPER_DEC_MULTIPLIER
ensures:
    ensures #range(0 <= RESULT <= maxSInt128)

[deposit_size-failure-1]
statusCode: _ => EVMC_BAD_JUMP_DESTINATION
+requires:
    andBool VALIDATOR_DEPOSIT *Int CUR_EPOCH_SCALE_FACTOR               <=Int maxSInt256
    andBool DECIMAL_RESULT ==Int VALIDATOR_DEPOSIT *Int CUR_EPOCH_SCALE_FACTOR /Int VYPER_DEC_MULTIPLIER
    andBool DECIMAL_RESULT >Int maxDecimal

[deposit_size-failure-21]
statusCode: _ => EVMC_REVERT
+requires:
    andBool VALIDATOR_DEPOSIT *Int CUR_EPOCH_SCALE_FACTOR               >Int maxSInt256
    andBool #range(0 <= chop(VALIDATOR_DEPOSIT *Int CUR_EPOCH_SCALE_FACTOR)             <= maxSInt256)

[deposit_size-failure-22]
statusCode: _ => EVMC_REVERT
+requires:
    andBool VALIDATOR_DEPOSIT *Int CUR_EPOCH_SCALE_FACTOR               >Int maxSInt256
    andBool #range(maxSInt256 <  chop(VALIDATOR_DEPOSIT *Int CUR_EPOCH_SCALE_FACTOR)            <= maxUInt256)

[esf]
callData: #abiCallData("esf", .TypedArgs)
callValue: 0

[esf-success]
output: _ => #asByteStackInWidth(CURRENT_EPOCH -Int LAST_FINALIZED_EPOCH, 32)
statusCode: _ => EVMC_SUCCESS
storage:
    // self.current_epoch : int128
    (#hashedLocation({COMPILER}, {CURRENT_EPOCH}, .IntList) |-> CURRENT_EPOCH)
    // self.last_finalized_epoch : int128
    (#hashedLocation({COMPILER}, {LAST_FINALIZED_EPOCH}, .IntList) |-> LAST_FINALIZED_EPOCH)
    _:Map
+requires:
    // Range
    andBool #rangeSInt(128, CURRENT_EPOCH)
    andBool #rangeSInt(128, LAST_FINALIZED_EPOCH)
    // Invariant
    andBool CURRENT_EPOCH >=Int 0
    andBool LAST_FINALIZED_EPOCH >=Int 0
    andBool CURRENT_EPOCH -Int LAST_FINALIZED_EPOCH >=Int 0
    //
    andBool CALLER_ID ==Int CASPER_ACCT_ID

[esf-failure]
output: _ => _
statusCode: _ => EVMC_INVALID
storage:
    _:Map
+requires:
    andBool CALLER_ID =/=Int CASPER_ACCT_ID


[collective_reward]
callData: #abiCallData("collective_reward", .TypedArgs)
callValue: 0

[collective_reward-success]
statusCode: _ => EVMC_SUCCESS
storage:
    // epoch:int128 = self.current_epoch
    (#hashedLocation({COMPILER}, {CURRENT_EPOCH}, .IntList) |-> EPOCH)
    // self.last_finalized_epoch : int128
    (#hashedLocation({COMPILER}, {LAST_FINALIZED_EPOCH}, .IntList)  |-> LAST_FINALIZED_EPOCH)
    // self.expected_source_epoch : int128
    (#hashedLocation({COMPILER}, {EXPECTED_SOURCE_EPOCH}, .IntList) |-> EXPECTED_SOURCE_EPOCH)
+requires:
    andBool CALLER_ID ==Int CASPER_ACCT_ID

    andBool #rangeSInt(128, EPOCH)
    andBool #rangeSInt(128, LAST_FINALIZED_EPOCH)
    andBool #rangeSInt(128, EXPECTED_SOURCE_EPOCH)

    andBool EPOCH                   >=Int 1
    andBool LAST_FINALIZED_EPOCH    >=Int 1
    andBool EXPECTED_SOURCE_EPOCH   >=Int 0

    // live: bool = self.esf() <= 2
    andBool ESF ==Int EPOCH -Int LAST_FINALIZED_EPOCH
    andBool ESF >=Int 0

[collective_reward-success-normal]
+storage:
    // self.total_curdyn_deposits : decimal
    (#hashedLocation({COMPILER}, {TOTAL_CURDYN_DEPOSITS}, .IntList)  |-> TOTAL_CURDYN_DEPOSITS)
    // self.total_prevdyn_deposits : decimal
    (#hashedLocation({COMPILER}, {TOTAL_PREVDYN_DEPOSITS}, .IntList) |-> TOTAL_PREVDYN_DEPOSITS)
    // self.votes[epoch - 1].cur_dyn_votes[self.expected_source_epoch] : decimal
    (#hashedLocation({COMPILER}, {VOTES}, (EPOCH -Int 1) {CUR_DYN_VOTES}  EXPECTED_SOURCE_EPOCH) |-> CUR_DYN_VOTES)
    // self.votes[epoch - 1].prev_dyn_votes[self.expected_source_epoch] : decimal
    (#hashedLocation({COMPILER}, {VOTES}, (EPOCH -Int 1) {PREV_DYN_VOTES} EXPECTED_SOURCE_EPOCH) |-> PREV_DYN_VOTES)
    // self.reward_factor : decimal
    (#hashedLocation({COMPILER}, {REWARD_FACTOR}, .IntList) |-> REWARD_FACTOR)
    _:Map
+requires:
    andBool #rangeSFixed(128, 10, TOTAL_CURDYN_DEPOSITS)
    andBool #rangeSFixed(128, 10, TOTAL_PREVDYN_DEPOSITS)
    andBool #rangeSFixed(128, 10, CUR_DYN_VOTES)
    andBool #rangeSFixed(128, 10, PREV_DYN_VOTES)
    andBool #rangeSFixed(128, 10, REWARD_FACTOR)

    andBool TOTAL_CURDYN_DEPOSITS   >=Int 0
    andBool TOTAL_PREVDYN_DEPOSITS  >=Int 0
    andBool CUR_DYN_VOTES           >=Int 0
    andBool PREV_DYN_VOTES          >=Int 0
    andBool REWARD_FACTOR           >=Int 0

    // there is no overflow because of these
    andBool CUR_DYN_VOTES  <=Int TOTAL_CURDYN_DEPOSITS
    andBool PREV_DYN_VOTES <=Int TOTAL_PREVDYN_DEPOSITS

    // deposit_exists() -> no division by zero
    andBool TOTAL_CURDYN_DEPOSITS  >Int 0
    andBool TOTAL_PREVDYN_DEPOSITS >Int 0
    // live
    andBool ESF <=Int 2

    // cur_vote_frac: decimal = self.votes[epoch - 1].cur_dyn_votes[self.expected_source_epoch] / self.total_curdyn_deposits
    andBool CUR_VOTE_FRAC  ==Int CUR_DYN_VOTES *Int VYPER_DEC_MULTIPLIER /Int TOTAL_CURDYN_DEPOSITS
    // prev_vote_frac: decimal = self.votes[epoch - 1].prev_dyn_votes[self.expected_source_epoch] / self.total_prevdyn_deposits
    andBool PREV_VOTE_FRAC ==Int PREV_DYN_VOTES *Int VYPER_DEC_MULTIPLIER /Int TOTAL_PREVDYN_DEPOSITS

[collective_reward-success-normal-1]
output: _ => #asByteStackInWidth(CUR_VOTE_FRAC *Int REWARD_FACTOR /Int VYPER_DEC_MULTIPLIER /Int 2, 32)
+requires:
    // vote_frac: decimal = min(cur_vote_frac, prev_vote_frac)
    andBool CUR_VOTE_FRAC <=Int PREV_VOTE_FRAC

[collective_reward-success-normal-2]
output: _ => #asByteStackInWidth(PREV_VOTE_FRAC *Int REWARD_FACTOR /Int VYPER_DEC_MULTIPLIER /Int 2, 32)
+requires:
    // vote_frac: decimal = min(cur_vote_frac, prev_vote_frac)
    andBool CUR_VOTE_FRAC >Int PREV_VOTE_FRAC

; `return 0.0` cases
[collective_reward-success-zero]
statusCode: _ => EVMC_SUCCESS
output: _ => #asByteStackInWidth(0, 32)

[collective_reward-success-zero-1]
+requires:
    andBool (TOTAL_PREVDYN_DEPOSITS ==Int 0
    orBool   TOTAL_CURDYN_DEPOSITS ==Int 0)

[collective_reward-success-zero-1-1]
+requires:
    // looks redundant but fails without it:
    // symbolic term remains inside `#asByteStack(bool2Word(...))`
    andBool ESF <=Int 2

[collective_reward-success-zero-1-2]
+requires:
    andBool ESF >Int 2

[collective_reward-success-zero-2]
+requires:
    andBool TOTAL_PREVDYN_DEPOSITS >Int 0
    andBool TOTAL_CURDYN_DEPOSITS  >Int 0
    andBool ESF >Int 2

[collective_reward-failure]
output: _ => _
statusCode: _ => EVMC_REVERT
storage: _:Map
+requires:
    andBool CALLER_ID =/=Int CASPER_ACCT_ID

[insta_finalize]
callData: #abiCallData("insta_finalize", .TypedArgs)
callValue: 0

[insta_finalize-success]
output: _ => .WordStack
statusCode: _ => EVMC_SUCCESS
log: _:List ( .List
            => ListItem(#abiEventLog(CASPER_ACCT_ID, "Epoch", #indexed(#int128(EPOCH -Int 1)), #indexed(#bytes32(EPOCH_HASH)), #bool(1), #bool(1)))
            )
storage:
    // epoch = self.current_epoch : int128
    (#hashedLocation({COMPILER}, {CURRENT_EPOCH}, .IntList) |-> EPOCH)
    // self.main_hash_justified
    (#hashedLocation({COMPILER}, {MAIN_HASH_JUSTIFIED}, .IntList) |-> (_ => 1))
    // assert self.votes[epoch - 1].is_justified
    (#hashedLocation({COMPILER}, {VOTES}, (EPOCH -Int 1) {IS_JUSTIFIED}) |-> (_ => 1))
    // assert self.votes[epoch - 1].is_finalized
    (#hashedLocation({COMPILER}, {VOTES}, (EPOCH -Int 1) {IS_FINALIZED}) |-> (_ => 1))
    // self.last_justified_epoch : int128
    (#hashedLocation({COMPILER}, {LAST_JUSTIFIED_EPOCH}, .IntList) |-> (_ => EPOCH -Int 1))
    // self.last_finalized_epoch : int128
    (#hashedLocation({COMPILER}, {LAST_FINALIZED_EPOCH}, .IntList) |-> (_ => EPOCH -Int 1))
    // self.checkpoint_hashes[epoch - 1]
    (#hashedLocation({COMPILER}, {CHECKPOINT_HASHES}, EPOCH -Int 1) |-> EPOCH_HASH)
    _:Map
+requires:
    // Range
    andBool #rangeSInt(128, EPOCH)
    andBool #rangeUInt(256, EPOCH_HASH)
    // Invariant
    andBool EPOCH >Int 1
    //
    andBool CALLER_ID ==Int CASPER_ACCT_ID

[insta_finalize-failure]
output: _ => _
statusCode: _ => EVMC_INVALID
storage:
    _:Map
+requires:
    andBool CALLER_ID =/=Int CASPER_ACCT_ID

[proc_reward]
comment:
k: (#execute => #halt) ~> _
output: _ => .WordStack
statusCode: _ => EVMC_SUCCESS
callStack: _
callData: #abiCallData("proc_reward", #int128(VINDEX), #int128(REWARD))
callValue: 0
wordStack: .WordStack => _
localMem: .Map => _
pc: 0 => _
gas: GCAP => NEW_GCAP
memoryUsed: 0 => _
callDepth: CD
log: _
refund: _ => _
coinbase: COINBASE_ACCT_ID
activeAccounts: SetItem(CASPER_ACCT_ID) SetItem(COINBASE_ACCT_ID) _:Set
casperBalance: CASPER_BAL => CASPER_BAL -Int ((REWARD *Int CUR_EPOCH_SCALE_FACTOR /Int 8) /Int 10000000000)
storage:
    // self.validators[validator_index].deposit
    (#hashedLocation({COMPILER}, {VALIDATORS}, VINDEX {DEPOSIT}) |-> (DEPOSIT => DEPOSIT +Int REWARD *Int 10000000000))
    // self.validators[validator_index].end_dynasty
    (#hashedLocation({COMPILER}, {VALIDATORS}, VINDEX {END_DYNASTY}) |-> END_DYN)
    // self.validators[validator_index].start_dynasty
    (#hashedLocation({COMPILER}, {VALIDATORS}, VINDEX {START_DYNASTY}) |-> START_DYN)
    // self.dynasty
    (#hashedLocation({COMPILER}, {DYNASTY}, .IntList) |-> CURRENT_DYN)
    // self.dynasty_wei_delta[end_dynasty]
    (#hashedLocation({COMPILER}, {DYNASTY_WEI_DELTA}, END_DYN) |-> (#unsigned(DYN_WEI_DELTA) => #unsigned(NEW_DYN_WEI_DELTA)))
    // self.total_curdyn_deposits
    (#hashedLocation({COMPILER}, {TOTAL_CURDYN_DEPOSITS}, .IntList) |-> (TOTAL_CURDYN_DEPOSITS => NEW_TOTAL_CURDYN_DEPOSITS))
    // self.total_prevdyn_deposits
    (#hashedLocation({COMPILER}, {TOTAL_PREVDYN_DEPOSITS}, .IntList) |-> (TOTAL_PREVDYN_DEPOSITS => NEW_TOTAL_PREVDYN_DEPOSITS))
    // self.deposit_scale_factor[self.current_epoch]
    (#hashedLocation({COMPILER}, {DEPOSIT_SCALE_FACTOR}, CURRENT_EPOCH) |-> CUR_EPOCH_SCALE_FACTOR)
    // self.current_epoch
    (#hashedLocation({COMPILER}, {CURRENT_EPOCH}, .IntList) |-> CURRENT_EPOCH)
    // self.default_end_dynasty
    (#hashedLocation({COMPILER}, {DEFAULT_END_DYNASTY}, .IntList) |-> DEFAULT_END_DYN)
    _:Map
accounts:
    <account>
      <acctID> COINBASE_ACCT_ID </acctID>
      <balance> COINBASE_BAL => COINBASE_BAL +Int ((REWARD *Int CUR_EPOCH_SCALE_FACTOR /Int 8) /Int 10000000000) </balance>
      <code> .WordStack </code>
      <storage> _ </storage>
      <origStorage> _ </origStorage>
      <nonce> COINBASE_NOUNCE </nonce>
    </account>
requires:
    andBool #rangeSInt(128, VINDEX)
    andBool #rangeSInt(128, REWARD)
    andBool #rangeAddress(COINBASE_ACCT_ID)
    andBool #rangeUInt(256, CASPER_BAL)
    andBool #rangeSFixed(128, 10, DEPOSIT)
    andBool #rangeSInt(128, END_DYN)
    andBool #rangeSInt(128, START_DYN)
    andBool #rangeSInt(128, CURRENT_DYN)
    andBool #rangeSFixed(128, 10, DYN_WEI_DELTA)
    andBool #rangeSFixed(128, 10, TOTAL_CURDYN_DEPOSITS)
    andBool #rangeSFixed(128, 10, TOTAL_PREVDYN_DEPOSITS)
    andBool #rangeSFixed(128, 10, CUR_EPOCH_SCALE_FACTOR)
    andBool #rangeSInt(128, CURRENT_EPOCH)
    andBool #rangeSInt(128, DEFAULT_END_DYN)
    andBool #rangeUInt(256, COINBASE_BAL)
    andBool #rangeUInt(256, COINBASE_NOUNCE)
    // Invariant
    andBool VINDEX >Int 0
    andBool REWARD >=Int 0
    andBool COINBASE_ACCT_ID >Int 0 andBool (notBool COINBASE_ACCT_ID in #precompiledAccounts(BYZANTIUM))
    andBool DEPOSIT >=Int 0
    andBool END_DYN >=Int 0
    andBool START_DYN >=Int 0
    //FIXME can be proved for CURRENT_DYN >= 0 as well, not clear if needed.
    andBool CURRENT_DYN -Int 1 >=Int 0
    andBool TOTAL_CURDYN_DEPOSITS >=Int 0
    andBool TOTAL_PREVDYN_DEPOSITS >=Int 0
    andBool CUR_EPOCH_SCALE_FACTOR >Int 0
    andBool CURRENT_EPOCH >=Int 0
    andBool DEFAULT_END_DYN >=Int 0
    andBool COINBASE_NOUNCE >Int 0
    // Overflow check
    andBool (DEPOSIT +Int REWARD *Int 10000000000) <=Int maxSFixed128x10
    andBool minSFixed128x10 <=Int NEW_DYN_WEI_DELTA
    andBool NEW_TOTAL_CURDYN_DEPOSITS <=Int maxSFixed128x10
    andBool NEW_TOTAL_PREVDYN_DEPOSITS <=Int maxSFixed128x10
    andBool REWARD *Int CUR_EPOCH_SCALE_FACTOR <=Int maxSFixed128x10
    andBool 0 <=Int CASPER_BAL -Int ((REWARD *Int CUR_EPOCH_SCALE_FACTOR /Int 8) /Int 10000000000)
    andBool COINBASE_BAL +Int ((REWARD *Int CUR_EPOCH_SCALE_FACTOR /Int 8) /Int 10000000000) <=Int maxUInt256

    //assignments
    andBool NEW_TOTAL_CURDYN_DEPOSITS:Int ==K #if IN_CURRENT_DYN
                                                #then TOTAL_CURDYN_DEPOSITS  +Int REWARD *Int 10000000000
                                                #else TOTAL_CURDYN_DEPOSITS
                                              #fi
    andBool NEW_TOTAL_PREVDYN_DEPOSITS:Int ==K #if IN_PREV_DYN
                                                #then TOTAL_PREVDYN_DEPOSITS  +Int REWARD *Int 10000000000
                                                #else TOTAL_PREVDYN_DEPOSITS
                                              #fi
    andBool NEW_DYN_WEI_DELTA ==K #if NEED_SUBSTRACT_REWARD
                                    #then DYN_WEI_DELTA -Int REWARD *Int 10000000000
                                    #else DYN_WEI_DELTA
                                  #fi

    // Path condition
    andBool CALLER_ID ==Int CASPER_ACCT_ID
    andBool IN_CURRENT_DYN:Bool          ==K #inCurDynasty(START_DYN, END_DYN, CURRENT_DYN)
    andBool IN_PREV_DYN:Bool             ==K #inPrevDynasty(START_DYN, END_DYN, CURRENT_DYN)
    andBool NEED_SUBSTRACT_REWARD:Bool   ==K END_DYN <Int DEFAULT_END_DYN
    andBool 0 <Int (REWARD *Int CUR_EPOCH_SCALE_FACTOR /Int 8) /Int 10000000000
    andBool CASPER_ACCT_ID =/=Int COINBASE_ACCT_ID
    // Call Depth
    andBool #range(0 <= CD < 1024)
    // Gas
    andBool GCAP >=Int (92207 +Int 2300) // Gcallstipend
ensures: ensures NEW_GCAP >=Int GCAP -Int 92207
attribute:

[vote]
comment:
k: (#execute => #halt) ~> _
output: _ => .WordStack
statusCode: _ => EVMC_REVERT /*will be rewritten later*/
callStack: _
callData: #abiCallData("vote", #int128(VALIDATOR_INDEX), #bytes32(TARGET_HASH), #int128(TARGET_EPOCH), #int128(SOURCE_EPOCH))
;callData: #abiCallData("vote", #toBytes(RLP(#int128(VALIDATOR_INDEX), #bytes32(TARGET_HASH), #int128(TARGET_EPOCH), #int128(SOURCE_EPOCH), #bytes(1024, SIG)), 1024))
callValue: 0
wordStack: .WordStack => _
localMem: .Map => _
pc: 0 => _
;gas cost 274618
gas: 10000000 => _
memoryUsed: 0 => _
callDepth: 0
log: _
refund: _ => _
coinbase: COINBASE_ACCT_ID
activeAccounts: SetItem(CASPER_ACCT_ID) SetItem(COINBASE_ACCT_ID) _:Set
casperBalance: CASPER_BAL => NEW_CASPER_BAL
storage:
    //used by recommended_target_hash()
    // self.current_epoch
    (#hashedLocation({COMPILER}, {CURRENT_EPOCH}, .IntList) |-> CURRENT_EPOCH)
    // self.EPOCH_LENGTH : int128
    (#hashedLocation({COMPILER}, {EPOCH_LENGTH}, .IntList) |-> EPOCH_LENGTH)

    // start_dynasty: int128 = self.validators[validator_index].start_dynasty
    (#hashedLocation({COMPILER}, {VALIDATORS}, VALIDATOR_INDEX {START_DYNASTY}) |-> START_DYN)
    // end_dynasty: int128 = self.validators[validator_index].end_dynasty
    (#hashedLocation({COMPILER}, {VALIDATORS}, VALIDATOR_INDEX {END_DYNASTY}) |-> END_DYN)
    // current_dynasty: int128 = self.dynasty
    (#hashedLocation({COMPILER}, {DYNASTY}, .IntList) |-> CURRENT_DYN)
    // self.votes[target_epoch].vote_bitmap[floor(validator_index / 256)]
    (#hashedLocation({COMPILER}, {VOTES}, TARGET_EPOCH {VOTE_BITMAP} V_ID_BITKEY) |-> (V_ID_BITWORD => NEW_V_ID_BITWORD))
    // self.votes[source_epoch].is_justified
    (#hashedLocation({COMPILER}, {VOTES}, SOURCE_EPOCH {IS_JUSTIFIED}) |-> SOURCE_IS_JUSTIFIED)
    // self.checkpoint_hashes[source_epoch]
    (#hashedLocation({COMPILER}, {CHECKPOINT_HASHES}, SOURCE_EPOCH) |-> SOURCE_EPOCH_HASH)
    // self.checkpoint_hashes[target_epoch]
    (#hashedLocation({COMPILER}, {CHECKPOINT_HASHES}, TARGET_EPOCH) |-> TARGET_EPOCH_HASH)
accounts:
    <account>
      <acctID> COINBASE_ACCT_ID </acctID>
      <balance> COINBASE_BAL => NEW_COINBASE_BAL </balance>
      <code> .WordStack </code>
      <storage> _ </storage>
      <origStorage> _ </origStorage>
      <nonce> COINBASE_NOUNCE </nonce>
    </account>
requires:
    // Type constraint
    andBool #rangeAddress(COINBASE_ACCT_ID)
    andBool (notBool COINBASE_ACCT_ID in #precompiledAccounts(BYZANTIUM))
    andBool #rangeSInt(128, VALIDATOR_INDEX)
    andBool 0  <Int VALIDATOR_INDEX         // start validator index counter at 1
    andBool #rangeUInt(256, TARGET_HASH)
    andBool #rangeSInt(128, TARGET_EPOCH)
    andBool 0 <=Int TARGET_EPOCH
    andBool #rangeSInt(128, SOURCE_EPOCH)
    andBool 0 <=Int SOURCE_EPOCH

    andBool #rangeSInt(128, CURRENT_EPOCH)
    andBool 0 <Int CURRENT_EPOCH
    andBool #rangeSInt(128, EPOCH_LENGTH)
    andBool 0 <Int EPOCH_LENGTH
    andBool #rangeSInt(128, START_DYN)
    andBool 0 <=Int START_DYN
    andBool #rangeSInt(128, END_DYN)
    andBool 0 <=Int END_DYN
    andBool #rangeSInt(128, CURRENT_DYN)
    //FIXME can be proved for CURRENT_DYN >= 0 as well, not clear if needed.
    andBool 0 <=Int CURRENT_DYN -Int 1
    andBool #rangeUInt(256, V_ID_BITWORD)
    andBool #rangeUInt(256, COINBASE_BAL)
    andBool #rangeUInt(256, CASPER_BAL)
    andBool #rangeUInt(256, SOURCE_EPOCH_HASH)
    andBool #rangeUInt(256, TARGET_EPOCH_HASH)

    andBool V_ID_BITKEY ==Int VALIDATOR_INDEX /Int 256
    andBool PAST_DYN ==Int CURRENT_DYN -Int 1
    andBool IN_CURRENT_DYN:Bool ==K ((START_DYN <=Int CURRENT_DYN) andBool (CURRENT_DYN <Int END_DYN))
    andBool IN_PREV_DYN:Bool    ==K ((START_DYN <=Int PAST_DYN)    andBool (PAST_DYN <Int END_DYN))
ensures:
attribute:

[vote-1-2-3-4-5-6]
+storage:
    // self.validators[validator_index].deposit
    //(#hashedLocation({COMPILER}, {VALIDATORS}, VALIDATOR_INDEX {DEPOSIT}) |-> (DEPOSIT => DEPOSIT +Int REWARD *Int 10000000000))
    (#hashedLocation({COMPILER}, {VALIDATORS}, VALIDATOR_INDEX {DEPOSIT}) |-> (DEPOSIT => NEW_DEPOSIT))
    // self.votes[target_epoch].cur_dyn_votes[source_epoch]
    (#hashedLocation({COMPILER}, {VOTES}, TARGET_EPOCH {CUR_DYN_VOTES} SOURCE_EPOCH) |-> (CUR_DYN_VOTES => NEW_CUR_DYN_VOTES))
    // self.votes[target_epoch].prev_dyn_votes[source_epoch]
    (#hashedLocation({COMPILER}, {VOTES}, TARGET_EPOCH {PREV_DYN_VOTES} SOURCE_EPOCH) |-> (PREV_DYN_VOTES => NEW_PREV_DYN_VOTES))
+requires:
    andBool #rangeSFixed(128, 10, DEPOSIT)
    andBool 0 <=Int DEPOSIT
    andBool #rangeSFixed(128, 10, CUR_DYN_VOTES)
    andBool 0 <=Int CUR_DYN_VOTES
    andBool #rangeSFixed(128, 10, PREV_DYN_VOTES)
    andBool 0 <=Int PREV_DYN_VOTES

    //overflow of computed values
    andBool NEW_CUR_DYN_VOTES    <=Int maxDecimal
    andBool NEW_PREV_DYN_VOTES   <=Int maxDecimal

    //FIXME more concrete cases
    andBool (IN_CURRENT_DYN orBool IN_PREV_DYN)

    //assignments
    andBool NEW_V_ID_BITWORD ==Int #setVoteBit(V_ID_BITWORD, VALIDATOR_INDEX)
    andBool NEW_CUR_DYN_VOTES:Int ==K #if IN_CURRENT_DYN #then CUR_DYN_VOTES +Int DEPOSIT #else CUR_DYN_VOTES #fi
    andBool NEW_PREV_DYN_VOTES:Int ==K #if IN_PREV_DYN #then PREV_DYN_VOTES +Int DEPOSIT #else PREV_DYN_VOTES #fi
    andBool NEW_TOTAL_CURDYN_DEPOSITS:Int ==K #if IN_CURRENT_DYN
                                                #then TOTAL_CURDYN_DEPOSITS  +Int REWARD *Int 10000000000
                                                #else TOTAL_CURDYN_DEPOSITS
                                              #fi
    andBool NEW_TOTAL_PREVDYN_DEPOSITS:Int ==K #if IN_PREV_DYN
                                                #then TOTAL_PREVDYN_DEPOSITS  +Int REWARD *Int 10000000000
                                                #else TOTAL_PREVDYN_DEPOSITS
                                              #fi
    andBool NEW_DYN_WEI_DELTA ==K             #if NEED_SUBSTRACT_REWARD
                                                #then DYN_WEI_DELTA -Int REWARD *Int 10000000000
                                                #else DYN_WEI_DELTA
                                              #fi

; Specs for the 3 cases generated by first 2 if statements.
; Combining all 3 paths in one spec: works after fixing lemmas for proc_reward.
[vote-1-2-3-4-5-6-success]
output: _ => .WordStack
statusCode: _ => EVMC_SUCCESS
log: _:List ( .List
            => ListItem(#abiEventLog(CASPER_ACCT_ID, "Epoch", #indexed(#int128(TARGET_EPOCH)), #indexed(#bytes32(TARGET_EPOCH_HASH)), #bool(1), #bool(0)))
               ListItem(#abiEventLog(CASPER_ACCT_ID, "Epoch", #indexed(#int128(SOURCE_EPOCH)), #indexed(#bytes32(SOURCE_EPOCH_HASH)), #bool(1), #bool(1)))
               ListItem(#abiEventLog(CASPER_ACCT_ID, "Vote", #indexed(#address(WITHDRAWAL_ADDR)), #indexed(#int128(VALIDATOR_INDEX)), #indexed(#bytes32(TARGET_HASH)), #int128(TARGET_EPOCH), #int128(SOURCE_EPOCH)))
            )
+storage:
    // self.validators[validator_index].withdrawal_addr
    (#hashedLocation({COMPILER}, {VALIDATORS}, VALIDATOR_INDEX {WITHDRAWAL_ADDR}) |-> WITHDRAWAL_ADDR)
    // self.dynasty_wei_delta[end_dynasty]
    (#hashedLocation({COMPILER}, {DYNASTY_WEI_DELTA}, END_DYN) |-> (#unsigned(DYN_WEI_DELTA) => #unsigned(NEW_DYN_WEI_DELTA)))
    // self.total_curdyn_deposits
    (#hashedLocation({COMPILER}, {TOTAL_CURDYN_DEPOSITS}, .IntList) |-> (TOTAL_CURDYN_DEPOSITS => NEW_TOTAL_CURDYN_DEPOSITS))
    // self.total_prevdyn_deposits
    (#hashedLocation({COMPILER}, {TOTAL_PREVDYN_DEPOSITS}, .IntList) |-> (TOTAL_PREVDYN_DEPOSITS => NEW_TOTAL_PREVDYN_DEPOSITS))

    // self.votes[source_epoch].is_finalized
    (#hashedLocation({COMPILER}, {VOTES}, SOURCE_EPOCH {IS_FINALIZED}) |-> (_ => 1))
    // self.votes[target_epoch].is_justified
    (#hashedLocation({COMPILER}, {VOTES}, TARGET_EPOCH {IS_JUSTIFIED}) |-> (0 => 1))

    // self.main_hash_justified
    (#hashedLocation({COMPILER}, {MAIN_HASH_JUSTIFIED}, .IntList) |-> (_ => 1))
    // self.deposit_scale_factor[self.current_epoch]
    (#hashedLocation({COMPILER}, {DEPOSIT_SCALE_FACTOR}, CURRENT_EPOCH) |-> CUR_EPOCH_SCALE_FACTOR)

    // self.last_finalized_epoch
    (#hashedLocation({COMPILER}, {LAST_FINALIZED_EPOCH}, .IntList) |-> (_ => SOURCE_EPOCH))
    // self.last_justified_epoch
    (#hashedLocation({COMPILER}, {LAST_JUSTIFIED_EPOCH}, .IntList) |-> (_ => TARGET_EPOCH))
    // self.reward_factor
    (#hashedLocation({COMPILER}, {REWARD_FACTOR}, .IntList) |-> REWARD_FACTOR)
    // self.expected_source_epoch
    (#hashedLocation({COMPILER}, {EXPECTED_SOURCE_EPOCH}, .IntList) |-> EXPECTED_SOURCE_EPOCH)
    // self.DEFAULT_END_DYNASTY
    (#hashedLocation({COMPILER}, {DEFAULT_END_DYNASTY}, .IntList) |-> DEFAULT_END_DYN)
    _:Map
+requires:
    andBool #rangeAddress(WITHDRAWAL_ADDR)
    andBool #rangeSFixed(128, 10, DYN_WEI_DELTA)
    andBool #rangeSFixed(128, 10, TOTAL_CURDYN_DEPOSITS)
    andBool 0 <=Int TOTAL_CURDYN_DEPOSITS
    andBool #rangeSFixed(128, 10, TOTAL_PREVDYN_DEPOSITS)
    andBool 0 <=Int TOTAL_PREVDYN_DEPOSITS
    andBool #rangeSFixed(128, 10, CUR_EPOCH_SCALE_FACTOR)
    andBool 0 <Int CUR_EPOCH_SCALE_FACTOR
    andBool #rangeSFixed(128, 10, REWARD_FACTOR)
    andBool 0 <Int REWARD_FACTOR    // assert self.reward_factor > 0 in `initialize_epoch()`
    andBool #rangeSInt(128, EXPECTED_SOURCE_EPOCH)
    andBool 0 <=Int EXPECTED_SOURCE_EPOCH
    andBool #rangeSInt(128, DEFAULT_END_DYN)
    andBool 0 <=Int DEFAULT_END_DYN

    andBool COINBASE_NOUNCE ==Int 1

    // Overflow check
    andBool (DEPOSIT *Int REWARD_FACTOR)    <=Int maxDecimal *Int 10000000000
    andBool ((TOTAL_CURDYN_DEPOSITS +Int REWARD *Int 10000000000)  *Int 2) <=Int maxDecimal
    andBool ((TOTAL_PREVDYN_DEPOSITS +Int REWARD *Int 10000000000) *Int 2) <=Int maxDecimal
    andBool (SOURCE_EPOCH +Int 1) <=Int maxSInt128
    andBool (DEPOSIT +Int REWARD *Int 10000000000) <=Int maxDecimal
    andBool minDecimal <=Int (DYN_WEI_DELTA -Int REWARD *Int 10000000000)
    //FIXME depending on conditions
    andBool TOTAL_CURDYN_DEPOSITS  +Int REWARD *Int 10000000000 <=Int maxDecimal
    andBool TOTAL_PREVDYN_DEPOSITS +Int REWARD *Int 10000000000 <=Int maxDecimal
    andBool REWARD *Int CUR_EPOCH_SCALE_FACTOR <=Int maxDecimal
    andBool 0 <=Int CASPER_BAL -Int ((REWARD *Int CUR_EPOCH_SCALE_FACTOR /Int 8) /Int 10000000000)
    andBool COINBASE_BAL +Int ((REWARD *Int CUR_EPOCH_SCALE_FACTOR /Int 8) /Int 10000000000) <=Int maxUInt256

    // Path constraint
    // recommended_target_hash overflow checks
    andBool (CURRENT_EPOCH *Int EPOCH_LENGTH)   <=Int maxSInt128
    andBool #range(BLOCK_NUM -Int 256 <= #expectedBlockNumber(CURRENT_EPOCH, EPOCH_LENGTH) < BLOCK_NUM)

    // if self.expected_source_epoch == source_epoch
    andBool SOURCE_EPOCH ==Int EXPECTED_SOURCE_EPOCH

    // proc_reward
    andBool REWARD  ==Int ((DEPOSIT *Int REWARD_FACTOR) /Int 10000000000) /Int 10000000000
    andBool NEED_SUBSTRACT_REWARD:Bool   ==K END_DYN <Int DEFAULT_END_DYN
    //FIXME remove when working. Removing entry below doesn't finish in 4 hours.
    andBool NEED_SUBSTRACT_REWARD
    andBool 0  <Int (REWARD *Int CUR_EPOCH_SCALE_FACTOR /Int 8) /Int 10000000000
    andBool CASPER_ACCT_ID =/=Int COINBASE_ACCT_ID

    // if (current_dynasty_votes >= self.total_curdyn_deposits * 2 / 3 and previous_dynasty_votes >= self.total_prevdyn_deposits * 2 / 3)
    andBool #isJustified(NEW_CUR_DYN_VOTES, TOTAL_CURDYN_DEPOSITS +Int REWARD *Int 10000000000, NEW_PREV_DYN_VOTES, TOTAL_PREVDYN_DEPOSITS +Int REWARD *Int 10000000000)
    // if target_epoch == source_epoch + 1
    andBool TARGET_EPOCH ==Int SOURCE_EPOCH +Int 1

    //assignments
    andBool NEW_COINBASE_BAL ==Int COINBASE_BAL +Int ((REWARD *Int CUR_EPOCH_SCALE_FACTOR /Int 8) /Int 10000000000)
    andBool NEW_CASPER_BAL ==Int CASPER_BAL -Int ((REWARD *Int CUR_EPOCH_SCALE_FACTOR /Int 8) /Int 10000000000)

[vote-1-2-3-4-5-6-success-1]
+requires:
    // WARN: Forced case analysis to overcome K limitations.
    andBool 0 <Int VALIDATOR_INDEX modInt 256

; FIXME does not work for general case, when IN_CURRENT_DYN and IN_PREV_DYN are not specified. Wrapping up Casper project.
;[vote-1-2-3-4-5-6-success-2]
;+requires:
;    //WARN: Forced case analysis to overcome K limitations.
;    andBool 0 ==Int (VALIDATOR_INDEX modInt 256)
;    //WARN: Redundant requirement. Consequence of the above and #notVoteBefore(...), required due to K limitations.
;    andBool (V_ID_BITWORD &Int 1) ==Int 0 //e.g. not voted before

; assert not bitwise_and(self.votes[target_epoch].vote_bitmap[floor(validator_index / 256)],
;                        shift(convert(1, 'uint256'), validator_index % 256))
[vote-1-failure-1]
+requires:
    //failure: assert not bitwise_and(...)
    andBool notBool #notVoteBefore(V_ID_BITWORD, VALIDATOR_INDEX)

    andBool 0 <Int VALIDATOR_INDEX modInt 256

[vote-1-failure-2]
+requires:
    //failure: assert not bitwise_and(...)
    andBool notBool #notVoteBefore(V_ID_BITWORD, VALIDATOR_INDEX)

    andBool 0 ==Int (VALIDATOR_INDEX modInt 256)
    andBool (V_ID_BITWORD &Int 1) ==Int 1 //e.g. voted before

; assert target_hash == self.recommended_target_hash()
[vote-1-2]
+requires:
    andBool #notVoteBefore(V_ID_BITWORD, VALIDATOR_INDEX)

    // recommended_target_hash overflow checks
    andBool (CURRENT_EPOCH *Int EPOCH_LENGTH)   <=Int maxSInt128
    andBool #range(BLOCK_NUM -Int 256 <= #expectedBlockNumber(CURRENT_EPOCH, EPOCH_LENGTH) < BLOCK_NUM)

; assert target_hash == self.recommended_target_hash()
[vote-1-2-failure-1]
+requires:
    // failure: assert target_hash == self.recommended_target_hash()
    andBool TARGET_HASH  =/=Int #recommendedBlockHash(BLOCK_HASHES, BLOCK_NUM, CURRENT_EPOCH, EPOCH_LENGTH)

    andBool 0 <Int VALIDATOR_INDEX modInt 256

[vote-1-2-failure-2]
+requires:
    // failure: assert target_hash == self.recommended_target_hash()
    andBool TARGET_HASH  =/=Int #recommendedBlockHash(BLOCK_HASHES, BLOCK_NUM, CURRENT_EPOCH, EPOCH_LENGTH)

    andBool 0 ==Int (VALIDATOR_INDEX modInt 256)
    andBool (V_ID_BITWORD &Int 1) ==Int 0

[vote-1-2-3]
+requires:
    // assert target_hash == self.recommended_target_hash()
    andBool TARGET_HASH  ==Int #recommendedBlockHash(BLOCK_HASHES, BLOCK_NUM, CURRENT_EPOCH, EPOCH_LENGTH)

; assert target_epoch == self.current_epoch
[vote-1-2-3-failure-1]
+requires:
    // failure: assert target_epoch == self.current_epoch
    andBool TARGET_EPOCH =/=Int CURRENT_EPOCH

    andBool 0 <Int VALIDATOR_INDEX modInt 256

[vote-1-2-3-failure-2]
+requires:
    // failure: assert target_epoch == self.current_epoch
    andBool TARGET_EPOCH =/=Int CURRENT_EPOCH

    andBool 0 ==Int (VALIDATOR_INDEX modInt 256)
    andBool (V_ID_BITWORD &Int 1) ==Int 0

[vote-1-2-3-4]
+requires:
    // assert target_epoch == self.current_epoch
    andBool TARGET_EPOCH ==Int CURRENT_EPOCH

; assert self.votes[source_epoch].is_justified
[vote-1-2-3-4-failure-1]
+requires:
    andBool SOURCE_IS_JUSTIFIED ==Int 0

    andBool 0 <Int VALIDATOR_INDEX modInt 256

[vote-1-2-3-4-failure-2]
+requires:
    andBool SOURCE_IS_JUSTIFIED ==Int 0

    andBool 0 ==Int (VALIDATOR_INDEX modInt 256)
    andBool (V_ID_BITWORD &Int 1) ==Int 0

[vote-1-2-3-4-5]
+requires:
    andBool SOURCE_IS_JUSTIFIED ==Int 1

; assert in_current_dynasty or in_prev_dynasty
[vote-1-2-3-4-5-failure-1]
+requires:
    andBool notBool (IN_CURRENT_DYN orBool IN_PREV_DYN)

    andBool 0 <Int VALIDATOR_INDEX modInt 256

[vote-1-2-3-4-5-failure-2]
+requires:
    andBool notBool (IN_CURRENT_DYN orBool IN_PREV_DYN)

    andBool 0 ==Int (VALIDATOR_INDEX modInt 256)
    andBool (V_ID_BITWORD &Int 1) ==Int 0


[delete_validator]
callData: #abiCallData("delete_validator", #int128(VINDEX))
callValue: 0
+requires:
    // Range
    andBool #rangeSInt(128, VINDEX)
    // Invariant
    andBool VINDEX >Int 0

[delete_validator-success]
output: _ => .WordStack
statusCode: _ => EVMC_SUCCESS
gas: GCAP => GCAP -Int 121213
refund: _ => _
storage:
    // self.validators[validator_index].deposit
    (#hashedLocation({COMPILER}, {VALIDATORS}, VINDEX {DEPOSIT}) |-> (VDEPOSIT => 0))
    // self.validators[validator_index].addr
    (#hashedLocation({COMPILER}, {VALIDATORS}, VINDEX {ADDR}) |-> (VADDR => 0))
    // self.validators[validator_index].end_dynasty
    (#hashedLocation({COMPILER}, {VALIDATORS}, VINDEX {END_DYNASTY}) |-> (END_DYN => 0))
    // self.validators[validator_index].start_dynasty
    (#hashedLocation({COMPILER}, {VALIDATORS}, VINDEX {START_DYNASTY}) |-> (START_DYN => 0))
    // self.validators[validator_index].withdrawal_addr
    (#hashedLocation({COMPILER}, {VALIDATORS}, VINDEX {WITHDRAWAL_ADDR}) |-> (VWITHDRAWALADDR => 0))
    // self.validator_indexes[self.validators[validator_index].withdrawal_addr]
    (#hashedLocation({COMPILER}, {VALIDATOR_INDEXES}, VWITHDRAWALADDR) |-> (VAL_IDX => 0))
    _:Map
+requires:
    // Range
    andBool #rangeSFixed(128, 10, VDEPOSIT)
    andBool #rangeAddress(VADDR)
    andBool #rangeSInt(128, END_DYN)
    andBool #rangeSInt(128, START_DYN)
    andBool #rangeAddress(VWITHDRAWALADDR)
    andBool #rangeSInt(128, VAL_IDX)
    // Gas
    andBool GCAP >=Int 121213
    // Path condition
    andBool CALLER_ID ==Int CASPER_ACCT_ID
    // Invariant
  //andBool VAL_IDX ==Int VINDEX

[delete_validator-failure]
output: _ => _
statusCode: _ => EVMC_INVALID
storage:
    _:Map
+requires:
    //Path condition
    andBool CALLER_ID =/=Int CASPER_ACCT_ID

[increment_dynasty]
comment:
k: (#execute => #halt) ~> _
output: _ => .WordStack
statusCode: _ => EVMC_SUCCESS
callStack: _
callData: #abiCallData("increment_dynasty", .TypedArgs)
callValue: 0
wordStack: .WordStack => _
localMem: .Map => _
pc: 0 => _
gas: 200000 => _
memoryUsed: 0 => _
callDepth: CD
log: _
refund: _ => _
coinbase: _
activeAccounts: SetItem(CASPER_ACCT_ID) _:Set
casperBalance: _
storage:
    // self.current_epoch : int128
    (#hashedLocation({COMPILER}, {CURRENT_EPOCH}, .IntList) |-> EPOCH)
accounts:
requires:
    andBool #range(0 <= CD < 1024)
    andBool #rangeSInt(128, EPOCH)
    andBool EPOCH >=Int 0

    andBool CALLER_ID ==Int CASPER_ACCT_ID
ensures:
attribute:

[increment_dynasty-is_finalized]
+storage:
    // self.votes[epoch - 2].is_finalized : bool
    (#hashedLocation({COMPILER}, {VOTES}, (EPOCH -Int 2) {IS_FINALIZED}) |-> 1)
    // self.dynasty : int128
    (#hashedLocation({COMPILER}, {DYNASTY}, .IntList) |-> (DYNASTY => DYNASTY +Int 1))
    //self.total_prevdyn_deposits : decimal = self.total_curdyn_deposits
    (#hashedLocation({COMPILER}, {TOTAL_PREVDYN_DEPOSITS}, .IntList)  |-> (_ => TOTAL_CURDYN_DEPOSITS))
    //self.total_curdyn_deposits : decimal += self.dynasty_wei_delta[self.dynasty]
    (#hashedLocation({COMPILER}, {TOTAL_CURDYN_DEPOSITS}, .IntList)
                                 |-> (TOTAL_CURDYN_DEPOSITS => TOTAL_CURDYN_DEPOSITS +Int DYNASTY_WEI_DELTA))
    //self.dynasty_wei_delta[self.dynasty] : decimal
    (#hashedLocation({COMPILER}, {DYNASTY_WEI_DELTA}, DYNASTY +Int 1)  |-> DYNASTY_WEI_DELTA)
    //self.dynasty_start_epoch[self.dynasty] :int128 = epoch
    (#hashedLocation({COMPILER}, {DYNASTY_START_EPOCH}, DYNASTY +Int 1)  |-> (_ => EPOCH))
    //self.dynasty_in_epoch[epoch] : int128 = self.dynasty
    (#hashedLocation({COMPILER}, {DYNASTY_IN_EPOCH}, EPOCH)  |-> (_ => DYNASTY +Int 1))
+requires:
    andBool EPOCH >=Int 2
    andBool #rangeSInt(128, DYNASTY)
    andBool #range(0 <= DYNASTY < maxSInt128)
    andBool #rangeSFixed(128, 10, TOTAL_CURDYN_DEPOSITS)
    andBool 0 <=Int TOTAL_CURDYN_DEPOSITS
    andBool #range(0 <= TOTAL_CURDYN_DEPOSITS +Int DYNASTY_WEI_DELTA <= maxDecimal)
    andBool #rangeSFixed(128, 10, DYNASTY_WEI_DELTA)

[increment_dynasty-not-is_finalized]
+storage:
    // self.votes[epoch - 2].is_finalized : bool
    (#hashedLocation({COMPILER}, {VOTES}, (EPOCH -Int 2) {IS_FINALIZED}) |-> 0)
    // self.dynasty : int128
    (#hashedLocation({COMPILER}, {DYNASTY}, .IntList) |-> DYNASTY)
    //self.dynasty_in_epoch[epoch] : int128 = self.dynasty
    (#hashedLocation({COMPILER}, {DYNASTY_IN_EPOCH}, EPOCH)  |-> (_ => DYNASTY))
+requires:
    andBool EPOCH >=Int 2
    andBool #rangeSInt(128, DYNASTY)

[increment_dynasty-is_finalized-justified]
+storage:
    //self.main_hash_justified : bool
    (#hashedLocation({COMPILER}, {MAIN_HASH_JUSTIFIED}, .IntList) |-> (1 => 0))
    //self.expected_source_epoch : int128 = epoch - 1
    (#hashedLocation({COMPILER}, {EXPECTED_SOURCE_EPOCH}, .IntList) |-> (_ => EPOCH -Int 1))
    _:Map

[increment_dynasty-is_finalized-not-justified]
+storage:
    //self.main_hash_justified : bool
    (#hashedLocation({COMPILER}, {MAIN_HASH_JUSTIFIED}, .IntList) |-> 0)
    _:Map

[increment_dynasty-not-is_finalized-justified]
+storage:
    //self.main_hash_justified : bool
    (#hashedLocation({COMPILER}, {MAIN_HASH_JUSTIFIED}, .IntList) |-> (1 => 0))
    //self.expected_source_epoch : int128 = epoch - 1
    (#hashedLocation({COMPILER}, {EXPECTED_SOURCE_EPOCH}, .IntList) |-> (_ => EPOCH -Int 1))
    _:Map

[increment_dynasty-not-is_finalized-not-justified]
+storage:
    //self.main_hash_justified : bool
    (#hashedLocation({COMPILER}, {MAIN_HASH_JUSTIFIED}, .IntList) |-> 0)
    _:Map

[logout]
comment:
k: (#execute => #halt) ~> _
output: _ => _
callStack: _
callData: #abiCallData("logout", #int128(VALIDATOR_INDEX), #int128(EPOCH))
callValue: 0
wordStack: .WordStack => _
localMem: .Map => _
pc: 0 => _
gas: 200000 => _
memoryUsed: 0 => _
callDepth: CD
log: _
refund: _ => _
coinbase: _
activeAccounts: SetItem(CASPER_ACCT_ID) _:Set
casperBalance: _
storage:
    // self.current_epoch : int128
    (#hashedLocation({COMPILER}, {CURRENT_EPOCH}, .IntList) |-> CURRENT_EPOCH)
    // block.number : int128 == BLOCK_NUM
    // self.EPOCH_LENGTH : int128
    (#hashedLocation({COMPILER}, {EPOCH_LENGTH}, .IntList) |-> EPOCH_LENGTH)
accounts:
requires:
    andBool #range(0 <= CD < 1024)
    andBool #rangeSInt(128, CURRENT_EPOCH)
    andBool CURRENT_EPOCH   >=Int 0
    andBool #rangeSInt(128, BLOCK_NUM)
    andBool BLOCK_NUM       >=Int 0
    andBool #rangeSInt(128, EPOCH_LENGTH)
    andBool EPOCH_LENGTH     >Int 0
    andBool #rangeSInt(128, VALIDATOR_INDEX)
    andBool VALIDATOR_INDEX    >=Int 0
    andBool #rangeSInt(128, EPOCH)
    andBool EPOCH    >=Int 0

ensures:
attribute:

; assert self.current_epoch == floor(block.number / self.EPOCH_LENGTH)
[logout-failure-1]
statusCode: _ => EVMC_REVERT
+requires:
    andBool CURRENT_EPOCH =/=Int BLOCK_NUM /Int EPOCH_LENGTH

; assert self.current_epoch >= epoch
[logout-failure-2]
statusCode: _ => EVMC_REVERT
+requires:
    andBool CURRENT_EPOCH ==Int BLOCK_NUM /Int EPOCH_LENGTH
    andBool CURRENT_EPOCH <Int EPOCH

[logout-12]
+storage:
    // self.dynasty : int128
    (#hashedLocation({COMPILER}, {DYNASTY}, .IntList) |-> DYNASTY)
    // self.DYNASTY_LOGOUT_DELAY : int128
    (#hashedLocation({COMPILER}, {DYNASTY_LOGOUT_DELAY}, .IntList) |-> DYNASTY_LOGOUT_DELAY)
+requires:
    andBool #rangeSInt(128, DYNASTY)
    andBool DYNASTY                     >=Int 0
    andBool #rangeSInt(128, DYNASTY_LOGOUT_DELAY)
    andBool DYNASTY_LOGOUT_DELAY         >Int 0

    andBool CURRENT_EPOCH ==Int BLOCK_NUM /Int EPOCH_LENGTH
    andBool CURRENT_EPOCH >=Int EPOCH
    andBool END_DYNASTY   ==Int DYNASTY +Int DYNASTY_LOGOUT_DELAY

; Overflow: end_dynasty: int128 = self.dynasty + self.DYNASTY_LOGOUT_DELAY
[logout-12-failure-3]
statusCode: _ => EVMC_BAD_JUMP_DESTINATION
+requires:
    andBool END_DYNASTY >Int maxSInt128

; assert self.validators[validator_index].end_dynasty > end_dynasty
[logout-12-failure-4]
statusCode: _ => EVMC_REVERT
+storage:
    // self.validators[validator_index].end_dynasty : int128
    (#hashedLocation({COMPILER}, {VALIDATORS}, VALIDATOR_INDEX {END_DYNASTY}) |-> VALIDATOR_END_DYNASTY)
+requires:
    andBool #rangeSInt(128, VALIDATOR_END_DYNASTY)
    andBool VALIDATOR_END_DYNASTY       >=Int 0

    andBool END_DYNASTY <=Int maxSInt128
    andBool VALIDATOR_END_DYNASTY <=Int END_DYNASTY

[logout-12-34]
+storage:
    // self.validators[validator_index].end_dynasty : int128
    (#hashedLocation({COMPILER}, {VALIDATORS}, VALIDATOR_INDEX {END_DYNASTY}) |-> (VALIDATOR_END_DYNASTY => END_DYNASTY))
    //self.validators[validator_index].deposit : decimal
    (#hashedLocation({COMPILER}, {VALIDATORS}, VALIDATOR_INDEX {DEPOSIT}) |-> DEPOSIT)
+requires:
    andBool #rangeSInt(128, VALIDATOR_END_DYNASTY)
    andBool VALIDATOR_END_DYNASTY       >=Int 0
    andBool #rangeSFixed(128, 10, DEPOSIT)
    andBool DEPOSIT                     >=Int 0

    andBool END_DYNASTY <=Int maxSInt128
    andBool VALIDATOR_END_DYNASTY >Int END_DYNASTY

; Overflow: self.dynasty_wei_delta[end_dynasty] -= self.validators[validator_index].deposit
[logout-12-34-failure-5]
statusCode: _ => EVMC_REVERT
+storage:
    // self.dynasty_wei_delta[end_dynasty] : decimal
    (#hashedLocation({COMPILER}, {DYNASTY_WEI_DELTA}, END_DYNASTY)  |-> #unsigned(DYNASTY_WEI_DELTA))
+requires:
    andBool #rangeSFixed(128, 10, DYNASTY_WEI_DELTA)
    andBool DYNASTY_WEI_DELTA -Int DEPOSIT <Int minDecimal

[logout-12-34-5-success]
output: _ => .WordStack
statusCode: _ => EVMC_SUCCESS
log: _:List ( .List
            => ListItem(#abiEventLog(CASPER_ACCT_ID, "Logout", #indexed(#address(WITHDRAWAL_ADDR)), #indexed(#int128(VALIDATOR_INDEX)), #int128(END_DYNASTY)))
            )
+storage:
    // self.dynasty_wei_delta[end_dynasty] : decimal
    (#hashedLocation({COMPILER}, {DYNASTY_WEI_DELTA}, END_DYNASTY)  |-> (#unsigned(DYNASTY_WEI_DELTA) => #unsigned(DYNASTY_WEI_DELTA -Int DEPOSIT)))
    // self.validators[validator_index].withdrawal_addr :address
    (#hashedLocation({COMPILER}, {VALIDATORS}, VALIDATOR_INDEX {WITHDRAWAL_ADDR}) |-> WITHDRAWAL_ADDR)
+requires:
    andBool #rangeSFixed(128, 10, DYNASTY_WEI_DELTA)
    andBool DYNASTY_WEI_DELTA -Int DEPOSIT >=Int minDecimal

    andBool #rangeAddress(WITHDRAWAL_ADDR)

[pgm]
compiler: "Vyper"
; self.validators
validators: 0
addr: 0
deposit: 1
end_dynasty: 2
start_dynasty: 3
withdrawal_addr: 4
; self.checkpoint_hashes
checkpoint_hashes: 1
; self.validator_indexes
validator_indexes: 3
; self.dynasty
dynasty: 4
; self.dynasty_wei_delta
dynasty_wei_delta: 5
; self.total_curdyn_deposits
total_curdyn_deposits: 6
; self.total_prevdyn_deposits
total_prevdyn_deposits: 7
; self.dynasty_in_epoch
dynasty_start_epoch: 8
; self.dynasty_in_epoch
dynasty_in_epoch: 9
; self.votes
votes: 10
cur_dyn_votes: 0
is_finalized: 1
is_justified: 2
prev_dyn_votes: 3
vote_bitmap: 4
; self.main_hash_justified
main_hash_justified: 11
; self.deposit_scale_factor
deposit_scale_factor: 12
; self.current_epoch
current_epoch: 15
; self.last_finalized_epoch
last_finalized_epoch: 16
; self.last_justified_epoch
last_justified_epoch: 17
; self.reward_factor
reward_factor: 18
; self.expected_source_epoch
expected_source_epoch: 19
; self.EPOCH_LENGTH
EPOCH_LENGTH: 21
; self.EPOCH_LENGTH
WITHDRAWAL_DELAY: 22
; self.EPOCH_LENGTH
DYNASTY_LOGOUT_DELAY: 23
; self.DEFAULT_END_DYNASTY
DEFAULT_END_DYNASTY: 30
code: "0x600035601c52740100000000000000000000000000000000000000006020526f7fffffffffffffffffffffffffffffff6040527fffffffffffffffffffffffffffffffff8000000000000000000000000000000060605274012a05f1fffffffffffffffffffffffffdabf41c006080527ffffffffffffffffffffffffed5fa0e000000000000000000000000000000000060a0526337df0ba8600051141561017b5734156100ac57600080fd5b60a051601354600f54600a60c052602060c0200160c052602060c02060c052602060c0200154600654806100df57600080fd5b806402540be400830205905090508060805190135857809190121561010357600080fd5b60a0516013546003600f54600a60c052602060c0200160c052602060c0200160c052602060c02001546007548061013957600080fd5b806402540be400830205905090508060805190135857809190121561015d57600080fd5b8082131561016b578061016d565b815b9050905060005260206000f3005b6399fb5eec6000511415610315576020600461014037341561019c57600080fd5b606051600435806040519013585780919012156101b857600080fd5b50600060a051600f54600c60c052602060c0200154600161014051600060c052602060c0200160c052602060c020015481810281198383830514176101fc57600080fd5b6402540be40081059050905090508060805190135857809190121561022057600080fd5b121561029e576402540be4006402540be3ff60a051600f54600c60c052602060c0200154600161014051600060c052602060c0200160c052602060c0200154818102811983838305141761027357600080fd5b6402540be40081059050905090508060805190135857809190121561029757600080fd5b030561030b565b6402540be40060a051600f54600c60c052602060c0200154600161014051600060c052602060c0200160c052602060c020015481810281198383830514176102e557600080fd5b6402540be40081059050905090508060805190135857809190121561030957600080fd5b055b60005260206000f3005b638ed137b0600051141561044257341561032e57600080fd5b600060a051600f54600c60c052602060c0200154600654818102811983838305141761035957600080fd5b6402540be40081059050905090508060805190135857809190121561037d57600080fd5b12156103e3576402540be4006402540be3ff60a051600f54600c60c052602060c020015460065481810281198383830514176103b857600080fd5b6402540be4008105905090509050806080519013585780919012156103dc57600080fd5b0305610438565b6402540be40060a051600f54600c60c052602060c0200154600654818102811983838305141761041257600080fd5b6402540be40081059050905090508060805190135857809190121561043657600080fd5b055b60005260206000f3005b6385f44a88600051141561056f57341561045b57600080fd5b600060a051600f54600c60c052602060c0200154600754818102811983838305141761048657600080fd5b6402540be4008105905090509050806080519013585780919012156104aa57600080fd5b1215610510576402540be4006402540be3ff60a051600f54600c60c052602060c020015460075481810281198383830514176104e557600080fd5b6402540be40081059050905090508060805190135857809190121561050957600080fd5b0305610565565b6402540be40060a051600f54600c60c052602060c0200154600754818102811983838305141761053f57600080fd5b6402540be40081059050905090508060805190135857809190121561056357600080fd5b055b60005260206000f3005b6310f24635600051141561059557341561058857600080fd5b60135460005260206000f3005b63855f372c60005114156106125734156105ae57600080fd5b6060516001606051601554600f5402806040519013585780919012156105d357600080fd5b03806040519013585780919012156105ea57600080fd5b61010043038112156105fb57600080fd5b43811061060757600080fd5b4060005260206000f3005b63de7f9975600051141561064e57341561062b57600080fd5b30331461063757600080fd5b6000600754136000600654131660005260206000f3005b63d286bb82600051141561076957341561066757600080fd5b30331461067357600080fd5b600f54610140526001606051600261014051038060405190135857809190121561069c57600080fd5b600a60c052602060c0200160c052602060c0200154156107235760046060516001825401806040519013585780919012156106d657600080fd5b815550600654600755600660a051600454600560c052602060c02001548254018060805190135857809190121561070c57600080fd5b81555061014051600454600860c052602060c02001555b60045461014051600960c052602060c0200155600b541561076257606051600161014051038060405190135857809190121561075e57600080fd5b6013555b6000600b55005b639a8eec7760005114156107b857341561078257600080fd5b30331461078e57600080fd5b606051601054600f5403806040519013585780919012156107ae57600080fd5b60005260206000f3005b63acc619c360005114156109c85734156107d157600080fd5b3033146107dd57600080fd5b600f5461014052600260206101e06004639a8eec776101805261019c6000305af161080757600080fd5b6101e05113156101605261016051156020610260600463de7f99756102005261021c6000305af161083757600080fd5b6102605115171561084d57600060005260206000f35b60a051601354606051600161014051038060405190135857809190121561087357600080fd5b600a60c052602060c0200160c052602060c02060c052602060c02001546006548061089d57600080fd5b806402540be40083020590509050806080519013585780919012156108c157600080fd5b6102805260a051601354600360605160016101405103806040519013585780919012156108ed57600080fd5b600a60c052602060c0200160c052602060c0200160c052602060c02001546007548061091857600080fd5b806402540be400830205905090508060805190135857809190121561093c57600080fd5b6102a052610280516102a051808213156109565780610958565b815b905090506102c05260a051600260a0516012546102c051818102811983838305141761098357600080fd5b6402540be4008105905090509050806080519013585780919012156109a757600080fd5b05806080519013585780919012156109be57600080fd5b60005260206000f3005b636526ed726000511415610b325734156109e157600080fd5b3033146109ed57600080fd5b600f54610140526001600b55600160026060516001610140510380604051901358578091901215610a1d57600080fd5b600a60c052602060c0200160c052602060c0200155600160016060516001610140510380604051901358578091901215610a5657600080fd5b600a60c052602060c0200160c052602060c02001556060516001610140510380604051901358578091901215610a8b57600080fd5b6011556060516001610140510380604051901358578091901215610aae57600080fd5b6010556001610160526001610180526060516001610140510380604051901358578091901215610add57600080fd5b600160c052602060c02001546060516001610140510380604051901358578091901215610b0957600080fd5b7f6940a3069a76fdb79d757f4dca548d7930f85e4bce3a3e2d06f5562bda0b10b96040610160a3005b63db23eee06000511415610e62573415610b4b57600080fd5b303314610b5757600080fd5b600f54610140526060516001600060a051670de0b6b3a764000060a0516060516001610140510380604051901358578091901215610b9457600080fd5b600c60c052602060c020015460075460065480821215610bb45780610bb6565b815b905090508181028119838383051417610bce57600080fd5b6402540be400810590509050905080608051901358578091901215610bf257600080fd5b0580608051901358578091901215610c0957600080fd5b1215610cc6576402540be4006402540be3ff60a051670de0b6b3a764000060a0516060516001610140510380604051901358578091901215610c4a57600080fd5b600c60c052602060c020015460075460065480821215610c6a5780610c6c565b815b905090508181028119838383051417610c8457600080fd5b6402540be400810590509050905080608051901358578091901215610ca857600080fd5b0580608051901358578091901215610cbf57600080fd5b0305610d72565b6402540be40060a051670de0b6b3a764000060a0516060516001610140510380604051901358578091901215610cfb57600080fd5b600c60c052602060c020015460075460065480821215610d1b5780610d1d565b815b905090508181028119838383051417610d3557600080fd5b6402540be400810590509050905080608051901358578091901215610d5957600080fd5b0580608051901358578091901215610d7057600080fd5b055b0180604051901358578091901215610d8957600080fd5b6101605260a0516404a817c80068056bc75e2d6310000061016051020580608051901358578091901215610dbc57600080fd5b610180526101a060006014818352015b60a051600260a05160a0516101805180610de557600080fd5b68056bc75e2d6310000061016051020580608051901358578091901215610e0b57600080fd5b610180510180608051901358578091901215610e2657600080fd5b0580608051901358578091901215610e3d57600080fd5b610180525b8151600101808352811415610dcc575b50506101805160005260206000f3005b635dcffc1760005114156112a75760206004610140373415610e8357600080fd5b60605160043580604051901358578091901215610e9f57600080fd5b50600060a05160155480610eb257600080fd5b6402540be40043020580608051901358578091901215610ed157600080fd5b1215610f19576402540be4006402540be3ff60a05160155480610ef357600080fd5b6402540be40043020580608051901358578091901215610f1257600080fd5b0305610f50565b6402540be40060a05160155480610f2f57600080fd5b6402540be40043020580608051901358578091901215610f4e57600080fd5b055b610160526060516001600f540180604051901358578091901215610f7357600080fd5b61014051146101605161014051131516610f8c57600080fd5b61014051600f5560a05160206101e0600463acc619c36101805261019c6000305af1610fb757600080fd5b6101e0516402540be4000180608051901358578091901215610fd857600080fd5b600e5560a051600e5460a0516012546402540be400018060805190135857809190121561100457600080fd5b8061100e57600080fd5b806402540be400830205905090508060805190135857809190121561103257600080fd5b600d5560a051600d54606051600161014051038060405190135857809190121561105b57600080fd5b600c60c052602060c0200154818102811983838305141761107b57600080fd5b6402540be40081059050905090508060805190135857809190121561109f57600080fd5b61014051600c60c052602060c020015560206102c0600463de7f99756102605261027c6000305af16110d057600080fd5b6102c051156111e35760a051601b546020610360600463db23eee06103005261031c6000305af161110057600080fd5b610360518061110e57600080fd5b806402540be400830205905090508060805190135857809190121561113257600080fd5b6102e05260a05160a051606051600260206103e06004639a8eec776103805261039c6000305af161116257600080fd5b6103e051038060405190135857809190121561117d57600080fd5b601c54818102811983838305141761119457600080fd5b80905090509050806080519013585780919012156111b157600080fd5b6102e05101806080519013585780919012156111cc57600080fd5b6012556000601254136111de57600080fd5b611209565b600060006004636526ed726102005261021c6000305af161120357600080fd5b60006012555b60006000600463d286bb826104005261041c6000305af161122957600080fd5b60206104c0600463855f372c6104605261047c6000305af161124a57600080fd5b6104c05161014051600160c052602060c020015560006104e05260006105005261014051600160c052602060c0200154610140517f6940a3069a76fdb79d757f4dca548d7930f85e4bce3a3e2d06f5562bda0b10b960406104e0a3005b63f9609f08600051141561162f57604060046101403760043560205181106112ce57600080fd5b5060243560205181106112e057600080fd5b50600060a051601554806112f357600080fd5b6402540be4004302058060805190135857809190121561131257600080fd5b121561135a576402540be4006402540be3ff60a0516015548061133457600080fd5b6402540be4004302058060805190135857809190121561135357600080fd5b0305611391565b6402540be40060a0516015548061137057600080fd5b6402540be4004302058060805190135857809190121561138f57600080fd5b055b600f541461139e57600080fd5b600060006004610180527fa1903eab000000000000000000000000000000000000000000000000000000006101a0526101806004806020846101e001018260208501600060046012f1505080518201915050610140516020826101e0010152602081019050806101e0526101e09050805160200180610260828460006004600a8704601201f161142d57600080fd5b50506020610300610260516102806000601a546207a120f161144e57600080fd5b60206102e0526102e060206000602083510381131561146c57600080fd5b046020026020018101519050141561148357600080fd5b61016051600360c052602060c02001541561149d57600080fd5b601d543412156114ac57600080fd5b606051600260045401806040519013585780919012156114cb57600080fd5b6103405260a051600f54600c60c052602060c0200154806114eb57600080fd5b68056bc75e2d631000003402058060805190135857809190121561150e57600080fd5b61036052600254600060c052602060c0200160c052602060c020610140518155610360516001820155601e5460028201556103405160038201556101605160048201555060025461016051600360c052602060c0200155600260605160018254018060405190135857809190121561158557600080fd5b81555061034051600560c052602060c0200160a05161036051825401806080519013585780919012156115b757600080fd5b8155506101405161038052600361016051600360c052602060c0200154600060c052602060c0200160c052602060c02001546103a052346103c05261016051600360c052602060c0200154610160517fc913dcae46368ac8a73eb63d4f2077a2de58e994bf2cddf074ab3a0fcaa3a0e16060610380a3005b6302459edc6000511415611875576040600461014037341561165057600080fd5b6060516004358060405190135857809190121561166c57600080fd5b506060516024358060405190135857809190121561168957600080fd5b50600060a0516015548061169c57600080fd5b6402540be400430205806080519013585780919012156116bb57600080fd5b1215611703576402540be4006402540be3ff60a051601554806116dd57600080fd5b6402540be400430205806080519013585780919012156116fc57600080fd5b030561173a565b6402540be40060a0516015548061171957600080fd5b6402540be4004302058060805190135857809190121561173857600080fd5b055b600f541461174757600080fd5b61016051600f54121561175957600080fd5b606051601754600454018060405190135857809190121561177957600080fd5b6101805261018051600261014051600060c052602060c0200160c052602060c0200154136117a657600080fd5b61018051600261014051600060c052602060c0200160c052602060c020015561018051600560c052602060c0200160a051600161014051600060c052602060c0200160c052602060c02001548254038060805190135857809190121561180b57600080fd5b815550600261014051600060c052602060c0200160c052602060c02001546101a05261014051600461014051600060c052602060c0200160c052602060c02001547fb0da0cd4d3f901fa403fa301bd3cad4934e079e9f1a5b61bdb33a03da2c9aaaf60206101a0a3005b6301b7af186000511415611922576020600461014037341561189657600080fd5b3033146118a257600080fd5b606051600435806040519013585780919012156118be57600080fd5b506000600461014051600060c052602060c0200160c052602060c0200154600360c052602060c020015561014051600060c052602060c0200160c052602060c020600081556000600182015560006002820155600060038201556000600482015550005b63edea14806000511415611c1f576020600461014037341561194357600080fd5b6060516004358060405190135857809190121561195f57600080fd5b506060516001600261014051600060c052602060c0200160c052602060c0200154018060405190135857809190121561199757600080fd5b60045412156119a557600080fd5b6060516001600261014051600060c052602060c0200160c052602060c020015401806040519013585780919012156119dc57600080fd5b600860c052602060c020015461016052606051601654610160510180604051901358578091901215611a0d57600080fd5b600f541215611a1b57600080fd5b600060a05161016051600c60c052602060c0200154600161014051600060c052602060c0200160c052602060c02001548181028119838383051417611a5f57600080fd5b6402540be400810590509050905080608051901358578091901215611a8357600080fd5b1215611b02576402540be4006402540be3ff60a05161016051600c60c052602060c0200154600161014051600060c052602060c0200160c052602060c02001548181028119838383051417611ad757600080fd5b6402540be400810590509050905080608051901358578091901215611afb57600080fd5b0305611b70565b6402540be40060a05161016051600c60c052602060c0200154600161014051600060c052602060c0200160c052602060c02001548181028119838383051417611b4a57600080fd5b6402540be400810590509050905080608051901358578091901215611b6e57600080fd5b055b61018052600060006000600061018051600461014051600060c052602060c0200160c052602060c02001546000f1611ba757600080fd5b610180516101a05261014051600461014051600060c052602060c0200160c052602060c02001547f499b9fc824d01426cfde5b95eebcfc53494a24d6316bb139b2333377f7c00e4760206101a0a36000600060246301b7af186101c052610140516101e0526101dc6000305af1611c1d57600080fd5b005b63579f38b26000511415611f695760406004610140373415611c4057600080fd5b303314611c4c57600080fd5b60605160043580604051901358578091901215611c6857600080fd5b5060605160243580604051901358578091901215611c8557600080fd5b50600161014051600060c052602060c0200160c052602060c0200160a0516402540be400610160510282540180608051901358578091901215611cc757600080fd5b815550600361014051600060c052602060c0200160c052602060c020015461018052600261014051600060c052602060c0200160c052602060c02001546101a0526004546101c05260605160016101c0510380604051901358578091901215611d2f57600080fd5b6101e0526101a0516101c051126101c0516101805113151615611d7957600660a0516402540be400610160510282540180608051901358578091901215611d7557600080fd5b8155505b6101a0516101e051126101e0516101805113151615611dbf57600760a0516402540be400610160510282540180608051901358578091901215611dbb57600080fd5b8155505b601e546101a0511215611e06576101a051600560c052602060c0200160a0516402540be400610160510282540380608051901358578091901215611e0257600080fd5b8155505b6000600060006000600060a051600860a051600f54600c60c052602060c0200154610160518181028119838383051417611e3f57600080fd5b8090509050905080608051901358578091901215611e5c57600080fd5b0580608051901358578091901215611e7357600080fd5b1215611eef576402540be4006402540be3ff60a051600860a051600f54600c60c052602060c0200154610160518181028119838383051417611eb457600080fd5b8090509050905080608051901358578091901215611ed157600080fd5b0580608051901358578091901215611ee857600080fd5b0305611f5a565b6402540be40060a051600860a051600f54600c60c052602060c0200154610160518181028119838383051417611f2457600080fd5b8090509050905080608051901358578091901215611f4157600080fd5b0580608051901358578091901215611f5857600080fd5b055b416000f1611f6757600080fd5b005b63d8b3772d60005114156128ad5760806004610140373415611f8a57600080fd5b60605160043580604051901358578091901215611fa657600080fd5b5060605160443580604051901358578091901215611fc357600080fd5b5060605160643580604051901358578091901215611fe057600080fd5b50600160605161010061014051078060405190135857809190121561200457600080fd5b60008113151561201c578060000360020a8204612023565b8060020a82025b90509050600060a0516101006402540be4006101405102058060805190135857809190121561205157600080fd5b1215612092576402540be4006402540be3ff60a0516101006402540be4006101405102058060805190135857809190121561208b57600080fd5b03056120c2565b6402540be40060a0516101006402540be400610140510205806080519013585780919012156120c057600080fd5b055b600461018051600a60c052602060c0200160c052602060c0200160c052602060c020015416156120f157600080fd5b6020610220600463855f372c6101c0526101dc6000305af161211257600080fd5b61022051610160511461212457600080fd5b600f54610180511461213557600080fd5b60026101a051600a60c052602060c0200160c052602060c020015461215957600080fd5b600361014051600060c052602060c0200160c052602060c020015461024052600261014051600060c052602060c0200160c052602060c0200154610260526004546102805260605160016102805103806040519013585780919012156121be57600080fd5b6102a05261026051610280511261028051610240511315166102c052610260516102a051126102a051610240511315166102e0526102e0516102c0511761220457600080fd5b600160605161010061014051078060405190135857809190121561222757600080fd5b60008113151561223f578060000360020a8204612246565b8060020a82025b90509050600060a0516101006402540be4006101405102058060805190135857809190121561227457600080fd5b12156122b5576402540be4006402540be3ff60a0516101006402540be400610140510205806080519013585780919012156122ae57600080fd5b03056122e5565b6402540be40060a0516101006402540be400610140510205806080519013585780919012156122e357600080fd5b055b600461018051600a60c052602060c0200160c052602060c0200160c052602060c020015417600060a0516101006402540be4006101405102058060805190135857809190121561233457600080fd5b1215612375576402540be4006402540be3ff60a0516101006402540be4006101405102058060805190135857809190121561236e57600080fd5b03056123a5565b6402540be40060a0516101006402540be400610140510205806080519013585780919012156123a357600080fd5b055b600461018051600a60c052602060c0200160c052602060c0200160c052602060c02001556101a05161018051600a60c052602060c0200160c052602060c02060c052602060c0200154610300526101a051600361018051600a60c052602060c0200160c052602060c0200160c052602060c0200154610320526102c0511561248e5761030060a051600161014051600060c052602060c0200160c052602060c02001548251018060805190135857809190121561246157600080fd5b815250610300516101a05161018051600a60c052602060c0200160c052602060c02060c052602060c02001555b6102e051156125015761032060a051600161014051600060c052602060c0200160c052602060c0200154825101806080519013585780919012156124d157600080fd5b815250610320516101a051600361018051600a60c052602060c0200160c052602060c0200160c052602060c02001555b6101a051601354141561267157600060a051601254600161014051600060c052602060c0200160c052602060c0200154818102811983838305141761254557600080fd5b6402540be40081059050905090508060805190135857809190121561256957600080fd5b12156125db576402540be4006402540be3ff60a051601254600161014051600060c052602060c0200160c052602060c020015481810281198383830514176125b057600080fd5b6402540be4008105905090509050806080519013585780919012156125d457600080fd5b030561263c565b6402540be40060a051601254600161014051600060c052602060c0200160c052602060c0200154818102811983838305141761261657600080fd5b6402540be40081059050905090508060805190135857809190121561263a57600080fd5b055b6103405260006000604463579f38b2610360526101405161038052610340516103a05261037c6000305af161267057600080fd5b5b600261018051600a60c052602060c0200160c052602060c02001541560a051600360a051600260075481810281198383830514176126ae57600080fd5b80905090509050806080519013585780919012156126cb57600080fd5b05806080519013585780919012156126e257600080fd5b61032051121560a051600360a0516002600654818102811983838305141761270957600080fd5b809050905090508060805190135857809190121561272657600080fd5b058060805190135857809190121561273d57600080fd5b610300511215161615612851576001600261018051600a60c052602060c0200160c052602060c0200155610180516011556001600b5560016104005260006104205261018051600160c052602060c0200154610180517f6940a3069a76fdb79d757f4dca548d7930f85e4bce3a3e2d06f5562bda0b10b96040610400a360605160016101a05101806040519013585780919012156127da57600080fd5b61018051141561285057600160016101a051600a60c052602060c0200160c052602060c02001556101a0516010556001610440526001610460526101a051600160c052602060c02001546101a0517f6940a3069a76fdb79d757f4dca548d7930f85e4bce3a3e2d06f5562bda0b10b96040610440a35b5b61018051610480526101a0516104a0526101605161014051600461014051600060c052602060c0200160c052602060c02001547f0fa814a7606272ed601db3d9974a12a26536f050d147ad209b7e7b0a95746f176040610480a4005b63cc20f16b600051141561322c57604060046101403734156128ce57600080fd5b610420600435600401610180376104006004356004013511156128f057600080fd5b6104206024356004016105c03761040060243560040135111561291257600080fd5b610180805160200180610a20828460006004600a8704601201f161293557600080fd5b50506020610e80610a2051610a40600060195462030d40f161295657600080fd5b6020610e6052610e6060206000602083510381131561297457600080fd5b046020026020018101519050610a0052611520610180610620610ec08251602084016000735185d17c44699cecc3133114f8df70753b856709610dc0f1505060c0610ec051146129c357600080fd5b610ec051610ec0018060200151600082518060209013585780919012156129e957600080fd5b606051816020036101000a830480604051901358578091901215612a0c57600080fd5b90509050905081526020610ee051610ec0015114612a2957600080fd5b610ee051610ee001518160200152610f0051610ec001806020015160008251806020901358578091901215612a5d57600080fd5b606051816020036101000a830480604051901358578091901215612a8057600080fd5b9050905090508160400152610f2051610ec001806020015160008251806020901358578091901215612ab157600080fd5b606051816020036101000a830480604051901358578091901215612ad457600080fd5b9050905090508160600152610f4051610ec00180516020018083608001828460006004600a8704601201f1612b0857600080fd5b505050611520516119e05261156051611a005261158051611a20526115a0805160200180611a40828460006004600a8704601201f1612b4657600080fd5b505060016000610a0051602082611e80010152602081019050611a4061040080602084611e8001018260208501600060046078f150508051820191505080611e8052611e8090508051602001806122e0828460006004600a8704601201f1612bad57600080fd5b505060206127606122e05161230060006119e051600060c052602060c0200160c052602060c020546207a120f1612be357600080fd5b602061274052612740602060006020835103811315612c0157600080fd5b04602002602001810151905014612c1757600080fd5b6105c08051602001806127c0828460006004600a8704601201f1612c3a57600080fd5b50506020612c206127c0516127e0600060195462030d40f1612c5b57600080fd5b6020612c0052612c00602060006020835103811315612c7957600080fd5b0460200260200181015190506127a0526132c06105c0610620612c608251602084016000735185d17c44699cecc3133114f8df70753b856709610dc0f1505060c0612c605114612cc857600080fd5b612c6051612c6001806020015160008251806020901358578091901215612cee57600080fd5b606051816020036101000a830480604051901358578091901215612d1157600080fd5b90509050905081526020612c8051612c60015114612d2e57600080fd5b612c8051612c8001518160200152612ca051612c6001806020015160008251806020901358578091901215612d6257600080fd5b606051816020036101000a830480604051901358578091901215612d8557600080fd5b9050905090508160400152612cc051612c6001806020015160008251806020901358578091901215612db657600080fd5b606051816020036101000a830480604051901358578091901215612dd957600080fd5b9050905090508160600152612ce051612c600180516020018083608001828460006004600a8704601201f1612e0d57600080fd5b5050506132c05161378052613300516137a052613320516137c0526133408051602001806137e0828460006004600a8704601201f1612e4b57600080fd5b5050600160006127a051602082613c200101526020810190506137e061040080602084613c2001018260208501600060046078f150508051820191505080613c2052613c209050805160200180614080828460006004600a8704601201f1612eb257600080fd5b50506020614500614080516140a0600061378051600060c052602060c0200160c052602060c020546207a120f1612ee857600080fd5b60206144e0526144e0602060006020835103811315612f0657600080fd5b04602002602001810151905014612f1c57600080fd5b613780516119e05114612f2e57600080fd5b6127a051610a00511415612f4157600080fd5b6000614540526137a051611a00511415612f6057600161454052612f94565b611a20516137c05112611a00516137a05113166137c051611a2051126137a051611a005113161715612f93576001614540525b5b61454051612fa157600080fd5b602061460060246399fb5eec614580526119e0516145a05261459c6000305af1612fca57600080fd5b6146005161456052600060a05160196402540be40061456051020580608051901358578091901215612ffb57600080fd5b121561303b576402540be4006402540be3ff60a05160196402540be4006145605102058060805190135857809190121561303457600080fd5b030561306a565b6402540be40060a05160196402540be4006145605102058060805190135857809190121561306857600080fd5b055b614620526060516146205161456051038060405190135857809190121561309057600080fd5b61464052601460605161464051825401806040519013585780919012156130b657600080fd5b815550614620516146605261464051614680526119e05160046119e051600060c052602060c0200160c052602060c0200154337fb63bb46c05149b79f409b978407acff3bb3bfb5fb728ed2909fdb52677c220da6040614660a460026119e051600060c052602060c0200160c052602060c02001546146a0526146a05160045412156131e95760016119e051600060c052602060c0200160c052602060c02001546146c0526060516001600454018060405190135857809190121561317a57600080fd5b600560c052602060c0200160a0516146c051825403806080519013585780919012156131a557600080fd5b815550601e546146a05112156131e8576146a051600560c052602060c0200160a0516146c051825401806080519013585780919012156131e457600080fd5b8155505b5b6000600060246301b7af186146e0526119e051614700526146fc6000305af161321157600080fd5b600060006000600061462051336000f161322a57600080fd5b005b6334ef39f1600051141561326657341561324557600080fd5b60006000600060006014546018546000f161325f57600080fd5b6000601455005b63253c8bd460005114156132ad576020600461014037341561328757600080fd5b600435602051811061329857600080fd5b503360185414156132ab57610140516018555b005b63bcc44d99600051141561331057602060046101403734156132ce57600080fd5b606051600435806040519013585780919012156132ea57600080fd5b50600161014051600060c052602060c0200160c052602060c020015460005260206000f3005b63faf944fa6000511415613373576020600461014037341561333157600080fd5b6060516004358060405190135857809190121561334d57600080fd5b50600361014051600060c052602060c0200160c052602060c020015460005260206000f3005b63c253bf4160005114156133d6576020600461014037341561339457600080fd5b606051600435806040519013585780919012156133b057600080fd5b50600261014051600060c052602060c0200160c052602060c020015460005260206000f3005b63bb0115f0600051141561343657602060046101403734156133f757600080fd5b6060516004358060405190135857809190121561341357600080fd5b5061014051600060c052602060c0200160c052602060c0205460005260206000f3005b635dbfd1ce6000511415613499576020600461014037341561345757600080fd5b6060516004358060405190135857809190121561347357600080fd5b50600461014051600060c052602060c0200160c052602060c020015460005260206000f3005b638208b87560005114156134f157602060046101403734156134ba57600080fd5b606051600435806040519013585780919012156134d657600080fd5b5061014051600160c052602060c020015460005260206000f3005b637d69c5d9600051141561351757341561350a57600080fd5b60025460005260206000f3005b63dc2059b36000511415613564576020600461014037341561353857600080fd5b600435602051811061354957600080fd5b5061014051600360c052602060c020015460005260206000f3005b637060054d600051141561358a57341561357d57600080fd5b60045460005260206000f3005b63c44dc65960005114156135e257602060046101403734156135ab57600080fd5b606051600435806040519013585780919012156135c757600080fd5b5061014051600560c052602060c020015460005260206000f3005b63a2630bae600051141561363a576020600461014037341561360357600080fd5b6060516004358060405190135857809190121561361f57600080fd5b5061014051600860c052602060c020015460005260206000f3005b6365ca80e66000511415613692576020600461014037341561365b57600080fd5b6060516004358060405190135857809190121561367757600080fd5b5061014051600960c052602060c020015460005260206000f3005b63fd87ef9d600051141561371c57604060046101403734156136b357600080fd5b606051600435806040519013585780919012156136cf57600080fd5b50606051602435806040519013585780919012156136ec57600080fd5b506101605161014051600a60c052602060c0200160c052602060c02060c052602060c020015460005260206000f3005b634ac756cb60005114156137a9576040600461014037341561373d57600080fd5b6060516004358060405190135857809190121561375957600080fd5b506060516024358060405190135857809190121561377657600080fd5b5061016051600361014051600a60c052602060c0200160c052602060c0200160c052602060c020015460005260206000f3005b6365fc181d600051141561383657604060046101403734156137ca57600080fd5b606051600435806040519013585780919012156137e657600080fd5b506060516024358060405190135857809190121561380357600080fd5b5061016051600461014051600a60c052602060c0200160c052602060c0200160c052602060c020015460005260206000f3005b63cce38da56000511415613899576020600461014037341561385757600080fd5b6060516004358060405190135857809190121561387357600080fd5b50600261014051600a60c052602060c0200160c052602060c020015460005260206000f3005b63634f21d260005114156138fc57602060046101403734156138ba57600080fd5b606051600435806040519013585780919012156138d657600080fd5b50600161014051600a60c052602060c0200160c052602060c020015460005260206000f3005b6399787ac6600051141561392257341561391557600080fd5b600b5460005260206000f3005b63e430757f600051141561397a576020600461014037341561394357600080fd5b6060516004358060405190135857809190121561395f57600080fd5b5061014051600c60c052602060c020015460005260206000f3005b638a48440760005114156139a057341561399357600080fd5b600d5460005260206000f3005b63e6b5736660005114156139c65734156139b957600080fd5b600e5460005260206000f3005b639372b4e460005114156139ec5734156139df57600080fd5b600f5460005260206000f3005b632eff87596000511415613a12573415613a0557600080fd5b60105460005260206000f3005b635f6116506000511415613a38573415613a2b57600080fd5b60115460005260206000f3005b6307dcf45b6000511415613a5e573415613a5157600080fd5b60125460005260206000f3005b635b03544a6000511415613a84573415613a7757600080fd5b60135460005260206000f3005b63ac4746ab6000511415613aaa573415613a9d57600080fd5b60155460005260206000f3005b630ebb172a6000511415613ad0573415613ac357600080fd5b60165460005260206000f3005b634f4ddb5e6000511415613af6573415613ae957600080fd5b60175460005260206000f3005b633f8a500e6000511415613b1c573415613b0f57600080fd5b601b5460005260206000f3005b6361073e886000511415613b42573415613b3557600080fd5b601c5460005260206000f3005b"
