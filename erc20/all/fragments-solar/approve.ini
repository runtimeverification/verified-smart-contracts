[approve]
    ; precondition
k:     saveEthereum V_CONF_BEFORE
    ~> #mkCallShortcut V_CONF_BEFORE CALLER_ID ACCT_ID
                       #abiCallData("balanceOf", #address(ANY_ADDR))                                V_ANY_BAL_BEFORE
    ~> #mkCallShortcut V_CONF_BEFORE CALLER_ID ACCT_ID
                       #abiCallData("allowance", #address(CALLER_ID), #address(SPENDER))            V_ALLOWANCE_BEFORE
    ~> #mkCallShortcut V_CONF_BEFORE CALLER_ID ACCT_ID
                       #abiCallData("allowance", #address(ANY_NONCALLER), #address(ANY_NONSPENDER)) V_OTHER_ALLOWANCE_BEFORE
    ~> #assume (getVar V_ALLOWANCE_BEFORE) ==S #buf(32, ALLOWANCE_BEFORE)
    ; tested function call
    ~> #mkCallShortcut V_CONF_BEFORE CALLER_ID ACCT_ID
                           #abiCallData("approve", #address(SPENDER), #uint256(VALUE))              V_APPROVE_OUT
    ~> saveEthereum V_CONF_AFTER
    ; retrieving postcondition data
    ~> #mkCallShortcut V_CONF_AFTER CALLER_ID ACCT_ID
                       #abiCallData("balanceOf", #address(ANY_ADDR))                                V_ANY_BAL_AFTER
    ~> #mkCallShortcut V_CONF_AFTER CALLER_ID ACCT_ID
                       #abiCallData("allowance", #address(CALLER_ID), #address(SPENDER))            V_ALLOWANCE_AFTER
    ~> #mkCallShortcut V_CONF_AFTER CALLER_ID ACCT_ID
                       #abiCallData("allowance", #address(ANY_NONCALLER), #address(ANY_NONSPENDER)) V_OTHER_ALLOWANCE_AFTER
    ; postcondition
    ~> restoreEthereum V_CONF_AFTER
    ; we use #assume instead of #assert here, to bind ALLOWANCE_AFTER and refer it from postcondition
    ~> #assume (getVar V_ALLOWANCE_AFTER)           ==S  #buf(32, ALLOWANCE_AFTER)
    ; check that balances are unchanged and allowances for other account pairs are unchanged
    ~> #assert (getVar V_ANY_BAL_BEFORE)            ==S  (getVar V_ANY_BAL_AFTER)
    ~> #assert (getVar V_OTHER_ALLOWANCE_BEFORE)    ==S  (getVar V_OTHER_ALLOWANCE_AFTER)
    => .
statusCode: _ => SC
output: _ => NEW_OUTPUT
log: OLD_LOG => NEW_LOG
refund: _ => _
storage: STORAGE1 => STORAGE2
requires:
    ; types
    andBool #rangeAddress(SPENDER)
    andBool #rangeUInt(256, VALUE)
    ; SOLAR vars
    andBool V_CONF_BEFORE               ==K String2Id("V_CONF_BEFORE")
    andBool V_CONF_AFTER                ==K String2Id("V_CONF_AFTER")
    andBool #rangeAddress(ANY_ADDR)
    andBool V_ANY_BAL_BEFORE            ==K String2Id("V_ANY_BAL_BEFORE")
    andBool V_ALLOWANCE_BEFORE          ==K String2Id("V_ALLOWANCE_BEFORE")
    andBool #rangeAddress(ANY_NONCALLER)
    andBool #rangeAddress(ANY_NONSPENDER)
    andBool ANY_NONCALLER               =/=Int CALLER_ID
    andBool ANY_NONSPENDER              =/=Int SPENDER
    andBool V_OTHER_ALLOWANCE_BEFORE    ==K String2Id("V_OTHER_ALLOWANCE_BEFORE")
    andBool V_APPROVE_OUT               ==K String2Id("V_APPROVE_OUT")
    andBool V_ANY_BAL_AFTER             ==K String2Id("V_ANY_BAL_AFTER")
    andBool V_ALLOWANCE_AFTER           ==K String2Id("V_ALLOWANCE_AFTER")
    andBool V_OTHER_ALLOWANCE_AFTER     ==K String2Id("V_OTHER_ALLOWANCE_AFTER")
ensures:
    andBool (
        (
            // return true
            SC ==K EVMC_SUCCESS
            andBool NEW_OUTPUT ==K #buf(32, 1)
            andBool NEW_LOG    ==K OLD_LOG ListItem(#abiEventLog(ACCT_ID, "Approval", #indexed(#address(CALLER_ID)), #indexed(#address(SPENDER)), #uint256(VALUE)))
            andBool ALLOWANCE_AFTER ==Int VALUE
        ) orBool (
            // revert
            SC =/=K EVMC_SUCCESS
            // pre-conditions
            {EXTRA_PRE_CONDITIONS}
        ) orBool (
            // return false
            SC ==K EVMC_SUCCESS andBool NEW_OUTPUT ==K #buf(32, 0)
            andBool OLD_LOG ==K NEW_LOG
            andBool STORAGE1 ==IMap STORAGE2
            // pre-conditions
            {EXTRA_PRE_CONDITIONS}
        )
    )
EXTRA_PRE_CONDITIONS:
    andBool (
        (
            CALLER_ID ==Int 0
        ) orBool (
            SPENDER ==Int 0
        ) orBool (
            VALUE ==Int 0
        ) orBool (
            VALUE =/=Int 0 andBool ALLOWANCE_BEFORE =/=Int 0   /* mitigates the ERC20 spend/approval race condition */
        ) orBool (
            ACCT_ID ==Int SPENDER /* 04_chainlink, non-ERC20-compliant */
        )
    )
