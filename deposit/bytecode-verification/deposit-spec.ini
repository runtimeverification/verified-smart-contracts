; contract: https://github.com/ethereum/eth2.0-specs/blob/v0.9.0/deposit_contract/contracts/validator_registration.v.py
; vyper: https://github.com/ethereum/vyper/releases/tag/v0.1.0-beta.13

[root]
k: #execute
; default
pc: 0 => _
word_stack: .WordStack => _
local_mem: .Map => _
gas: #symGas(G, 0, 0, .List, Cmem({SCHEDULE}, #symMem(0, .Set))) => _
memory_used: #symMem(0, .Set) => _
; no changes
call_data: _
log: _
refund: _
storage: _
orig_storage: _
balance: INIT_BALANCE
nonce: INIT_NONCE
code: {RUNTIME_CODE}
; ignore (potential) changes
output: _ => _
status_code: _ => _
; variables
comment:
schedule:       ISTANBUL
call_stack:     CALL_STACK
this:           THIS
msg_sender:     MSG_SENDER
call_value:     CALL_VALUE
call_depth:     CALL_DEPTH
coinbase:       COIN_BASE
active_accounts:
accounts:
requires:
    // conditions
    andBool #range(0 <= CALL_DEPTH < 1024)
    andBool #regularAddress({SCHEDULE}, THIS)
    // types
    andBool #rangeAddress(THIS)
    andBool #rangeAddress(MSG_SENDER)
    andBool #rangeUInt(256, CALL_VALUE)
;   andBool #rangeUInt(256, INIT_GAS)
    andBool #rangeUInt(256, INIT_BALANCE)
    andBool #rangeUInt(256, INIT_NONCE)
    andBool #rangeUInt(256, EXTRA_CALL_DATA_SIZE)
    andBool isInitGas(G)
ensures:
attribute:
VYPER_GENERATED_BOUNDS:
    ; bounds - vyper generated
    [  32 := #buf(32, 1461501637330902918203684832716283019655932542976) ]
    [  64 := #buf(32, 170141183460469231731687303715884105727) ]
    [  96 := #buf(32, 115792089237316195423570985008687907853099843482180094807725896704197245534208) ]
    [ 128 := #buf(32, 1701411834604692317316873037158841057270000000000) ]
    [ 160 := #buf(32, 115792089237316195423570985006986496018665292348323691002298742950633129639936) ]
LOCAL_MEM_UPDATE_BY_TO_LITTLE_ENDIAN_64_DEPOSIT_COUNT:
    [ 352 := #buf(32, {RETURN_ADDR_FROM_TO_LITTLE_ENDIAN_64}) ]  /* return address */
    [ 320 := #buf(32, DEPOSIT_COUNT) ]  /* argument */
    [ 384 := #buf(32, Y8) ]             /* y: uint256 = (y << 8) + bitwise_and(x, 255) */
    [ 416 := #buf(32, X8) ]             /* x: uint256 = (x >> 8) */
    [ 448 := #buf(32, 8) ]              /* for-loop index */
    [ 480 := #buf(32, X7 &Int 255) ]    /* bitwise_and(x, 255) */
    [ 544 := #buf(32, Y8) ]             /* memcpy(544 <- 384, 32) */
    [ 536 := #buf(32, 8) ]              /* for slice(convert(y, bytes32), start=24, len=8) */
    [ 704 := #buf(32, 8) ++ #bufSeg(#buf(32, Y8), 24, 8) ]  /* return: bytes[8] */ /* memcpy(704 <- 536, 40) */
    {TO_LITTLE_ENDIAN_64_ZERO_PADDING}
LOCAL_MEM_UPDATE_BY_TO_LITTLE_ENDIAN_64_DEPOSIT_AMOUNT:
    [ 352 := #buf(32, {RETURN_ADDR_FROM_TO_LITTLE_ENDIAN_64_DEPOSIT_AMOUNT}) ]  /* return address */
    [ 320 := #buf(32, {DEPOSIT_AMOUNT}) ]   /* argument */
    [ 384 := #buf(32, YY8) ]                /* y: uint256 = (y << 8) + bitwise_and(x, 255) */
    [ 416 := #buf(32, XX8) ]                /* x: uint256 = (x >> 8) */
    [ 448 := #buf(32, 8) ]                  /* for-loop index */
    [ 480 := #buf(32, XX7 &Int 255) ]       /* bitwise_and(x, 255) */
    [ 544 := #buf(32, YY8) ]                /* memcpy(544 <- 384, 32) */
    [ 536 := #buf(32, 8) ]                  /* for slice(convert(y, bytes32), start=24, len=8) */
    [ 704 := #buf(32, 8) ++ #bufSeg(#buf(32, YY8), 24, 8) ]  /* return: bytes[8] */ /* memcpy(704 <- 536, 40) */
    {TO_LITTLE_ENDIAN_64_ZERO_PADDING}
TO_LITTLE_ENDIAN_64_ZERO_PADDING:
    [ 800 := #buf(32, 32) ]             /* padding loop index */
    [ 744 <- 0 ]                        /* padding */
    [ 745 <- 0 ]
    [ 746 <- 0 ]
    [ 747 <- 0 ]
    [ 748 <- 0 ]
    [ 749 <- 0 ]
    [ 750 <- 0 ]
    [ 751 <- 0 ]
    [ 752 <- 0 ]
    [ 753 <- 0 ]
    [ 754 <- 0 ]
    [ 755 <- 0 ]
    [ 756 <- 0 ]
    [ 757 <- 0 ]
    [ 758 <- 0 ]
    [ 759 <- 0 ]
    [ 760 <- 0 ]
    [ 761 <- 0 ]
    [ 762 <- 0 ]
    [ 763 <- 0 ]
    [ 764 <- 0 ]
    [ 765 <- 0 ]
    [ 766 <- 0 ]
    [ 767 <- 0 ]
    [ 672 := #buf(32, 32) ]             /* ??? */
    [ 640 := #buf(32, 0) ]              /* ??? */
LET_BINDINGS_OF_TO_LITTLE_ENDIAN_64_DEPOSIT_COUNT:
    // let-bindings
    andBool X1 ==Int DEPOSIT_COUNT /Int 256
    andBool X2 ==Int X1            /Int 256
    andBool X3 ==Int X2            /Int 256
    andBool X4 ==Int X3            /Int 256
    andBool X5 ==Int X4            /Int 256
    andBool X6 ==Int X5            /Int 256
    andBool X7 ==Int X6            /Int 256
    andBool X8 ==Int X7            /Int 256
    //
    andBool Y1 ==Int          DEPOSIT_COUNT &Int 255
    andBool Y2 ==Int (Y1 *Int 256) +Int (X1 &Int 255)
    andBool Y3 ==Int (Y2 *Int 256) +Int (X2 &Int 255)
    andBool Y4 ==Int (Y3 *Int 256) +Int (X3 &Int 255)
    andBool Y5 ==Int (Y4 *Int 256) +Int (X4 &Int 255)
    andBool Y6 ==Int (Y5 *Int 256) +Int (X5 &Int 255)
    andBool Y7 ==Int (Y6 *Int 256) +Int (X6 &Int 255)
    andBool Y8 ==Int (Y7 *Int 256) +Int (X7 &Int 255)
LET_BINDINGS_OF_TO_LITTLE_ENDIAN_64_DEPOSIT_AMOUNT:
    // let-bindings
    andBool XX1 ==Int {DEPOSIT_AMOUNT} /Int 256
    andBool XX2 ==Int XX1              /Int 256
    andBool XX3 ==Int XX2              /Int 256
    andBool XX4 ==Int XX3              /Int 256
    andBool XX5 ==Int XX4              /Int 256
    andBool XX6 ==Int XX5              /Int 256
    andBool XX7 ==Int XX6              /Int 256
    andBool XX8 ==Int XX7              /Int 256
    //
    andBool YY1 ==Int         {DEPOSIT_AMOUNT} &Int 255
    andBool YY2 ==Int (YY1 *Int 256) +Int (XX1 &Int 255)
    andBool YY3 ==Int (YY2 *Int 256) +Int (XX2 &Int 255)
    andBool YY4 ==Int (YY3 *Int 256) +Int (XX3 &Int 255)
    andBool YY5 ==Int (YY4 *Int 256) +Int (XX4 &Int 255)
    andBool YY6 ==Int (YY5 *Int 256) +Int (XX5 &Int 255)
    andBool YY7 ==Int (YY6 *Int 256) +Int (XX6 &Int 255)
    andBool YY8 ==Int (YY7 *Int 256) +Int (XX7 &Int 255)

;
; __init__
;

; @public
; def __init__():
;     for i in range(DEPOSIT_CONTRACT_TREE_DEPTH - 1):
;         self.zero_hashes[i + 1] = sha256(concat(self.zero_hashes[i], self.zero_hashes[i]))

[init]
; for create
code: {INIT_CODE}
call_data: .WordStack
storage: .Map
orig_storage: .Map
; for constructor
PC_LOOPENTER: 164
PC_LOOPHEAD: 369
PC_END: 4752
WORD_STACK_INIT: 31 : 320 : .WordStack
LOCAL_MEM_INIT: .Map
    {VYPER_GENERATED_BOUNDS}
    [ 320 := #buf(32, 0) ]              /* i = 0 */

[init-init]
pc: 0 => {PC_LOOPENTER}
word_stack: .WordStack => {WORD_STACK_INIT}
local_mem: .Map => {LOCAL_MEM_INIT}
+requires:
    // conditions
    andBool CALL_VALUE ==Int 0
gas:         #symGas(G, 0 => {GAS_COST}, 0 => {GAS_COST}, .List, Cmem({SCHEDULE}, {MEMORY_USED}))
memory_used: #symMem(0 => 352, .Set)
GAS_COST: 85

[init-loop0]
pc: {PC_LOOPENTER} => {PC_LOOPHEAD}
word_stack: {WORD_STACK_INIT} => 1 : {WORD_STACK_INIT}
local_mem: {LOCAL_MEM_INIT} => {LOCAL_MEM_INIT}
    [ 192 := #buf(32, 2) ]                  /* zero_hashes storage index = 2 */
    [ 384 := #buf(32, select(.Map, #hashedLocation({COMPILER}, {ZERO_HASHES}, 0))) ]    /* self.zero_hashes[0] */
    [ 416 := #buf(32, select(.Map, #hashedLocation({COMPILER}, {ZERO_HASHES}, 0))) ]    /* self.zero_hashes[0] */
    [ 352 := #buf(32, 64) ]                 /* size of sha256 */
    [ 192 := #buf(32, {ZERO_HASHES_1}) ]    /* sha256(384, 64) return */
    [ 192 := #buf(32, 2) ]                  /* zero_hashes storage index = 2 */
    [ 320 := #buf(32, 1) ]                  /* i = 1 */
storage: .Map => .Map
    [ #hashedLocation({COMPILER}, {ZERO_HASHES}, 1) <- {ZERO_HASHES_1} ]
refund: _ => _
ZERO_HASHES_1: #sha256(#buf(32, 0) ++ #buf(32, 0))
gas:         #symGas(G, 0 => {GAS_COST}, 0 => {GAS_COST}, .List, Cmem({SCHEDULE}, {MEMORY_USED}))
memory_used: #symMem(352 => 448, .Set)
GAS_COST: 21667

[init-loop]
LOCAL_MEM_LOOPHEAD: {LOCAL_MEM_INIT}
    [ 192 := #buf(32, 2) ]              /* zero_hashes storage index = 2 */
    [ 384 := #buf(32, ANON_1) ]         /* self.zero_hashes[i] */
    [ 416 := #buf(32, ANON_2) ]         /* self.zero_hashes[i] */
    [ 352 := #buf(32, 64) ]             /* size of sha256 */
    [ 320 := #buf(32, I) ]              /* i = i + 1 */
storage: M
+requires:
    // conditions
    andBool #range(0 <= I <= 31)
    // types
    andBool isStorage(M)
    andBool #rangeUInt(256, ANON_1)
    andBool #rangeUInt(256, ANON_2)

[init-loop-enter]
pc: {PC_LOOPHEAD}
word_stack: (I => I +Int 1) : {WORD_STACK_INIT}
local_mem: {LOCAL_MEM_LOOPHEAD} => {LOCAL_MEM_LOOPHEAD}
    [ 192 := #buf(32, 2) ]                  /* zero_hashes storage index = 2 */
    [ 384 := #buf(32, select(M, #hashedLocation({COMPILER}, {ZERO_HASHES}, I))) ]  /* self.zero_hashes[i] */
    [ 416 := #buf(32, select(M, #hashedLocation({COMPILER}, {ZERO_HASHES}, I))) ]  /* self.zero_hashes[i] */
    [ 352 := #buf(32, 64) ]                 /* size of sha256 */
    [ 192 := #buf(32, {ZERO_HASHES_I+1}) ]  /* sha256(384, 64) return */
    [ 192 := #buf(32, 2) ]                  /* zero_hashes storage index = 2 */
    [ 320 := #buf(32, I +Int 1) ]           /* i = i + 1 */
storage: M => M
    [ #hashedLocation({COMPILER}, {ZERO_HASHES}, I +Int 1) <- {ZERO_HASHES_I+1} ]
refund: _ => _
ZERO_HASHES_I: select(M, #hashedLocation({COMPILER}, {ZERO_HASHES}, I))
ZERO_HASHES_I+1: #sha256(#buf(32, {ZERO_HASHES_I}) ++ #buf(32, {ZERO_HASHES_I}))
+requires:
    // conditions
    andBool I <Int 31
gas:         #symGas(G, 0 => 6689, 0 => 21689, .List, Cmem({SCHEDULE}, {MEMORY_USED}))
memory_used: #symMem(448, .Set)

[init-loop-exit]
k: #execute => #halt
pc: {PC_LOOPHEAD} => {PC_END}
output: _ => #parseByteStack({RUNTIME_CODE})
word_stack: I : {WORD_STACK_INIT} => .WordStack
local_mem: {LOCAL_MEM_LOOPHEAD} => {LOCAL_MEM_LOOPHEAD}
    [ 0 := #parseByteStack({RUNTIME_CODE}) ]
+requires:
    // conditions
    andBool I ==Int 31
gas:         #symGas(G, 0 => {GAS_COST}, 0 => {GAS_COST}, .List, Cmem({SCHEDULE}, {MEMORY_USED}))
memory_used: #symMem(448 => 4346, .Set)
GAS_COST: 477

;
; to_little_endian_64
;

[to_little_endian_64-trusted]
gas:         #symGas(G, LB => LB +Int {GAS_COST}, UB => UB +Int {GAS_COST}, GS, Cmem({SCHEDULE}, {MEMORY_USED}))
memory_used: #symMem(MU => maxInt(MU, {MEM_COST}), MUS)
attribute: [trusted, matching(#symGas,#symMem,Cmem)]

[to_little_endian_64]
k: #execute
pc: {PC_BEGIN} => {PC_END}
word_stack: {WORD_STACK_BEGIN} => {WORD_STACK_END}
local_mem: {LOCAL_MEM_BEGIN} => {LOCAL_MEM_END}
LOOP_BOUND: 8
SLICE_LENGTH: 8
PC_BEGIN:  169
PC_MIDDLE: 387
PC_END:    643
WORD_STACK_BEGIN:  RETURN_ADDR : VALUE                 : WS /* WS saves caller's local vars */
WORD_STACK_MIDDLE: {LOOP_BOUND} : 448                  : WS
WORD_STACK_END:    RETURN_ADDR : 32 : 8 : {RETURN_VAL} : WS
; RETURN_VAL: selectRange({LOCAL_MEM_END}, 736, 32)
RETURN_VAL: #asWord(#bufSeg(#buf(32, Y8), 24, 8) ++ #buf(24, 0))
LOCAL_MEM_BEGIN:  MEM
LOCAL_MEM_MIDDLE: {LOCAL_MEM_BEGIN}  {LOCAL_MEM_UPDATE_FROM_BEGIN_TO_MIDDLE}
LOCAL_MEM_END:    {LOCAL_MEM_MIDDLE} {LOCAL_MEM_UPDATE_FROM_MIDDLE_TO_END}
LOCAL_MEM_UPDATE_FROM_BEGIN_TO_MIDDLE:
    [ 352 := #buf(32, RETURN_ADDR) ]
    [ 320 := #buf(32, VALUE) ]
    [ 384 := #buf(32, Y8) ]             /* y: uint256 = (y << 8) + bitwise_and(x, 255) */
    [ 416 := #buf(32, X8) ]             /* x: uint256 = (x >> 8) */
    [ 448 := #buf(32, {LOOP_BOUND}) ]   /* for-loop index */
    [ 480 := #buf(32, X7 &Int 255) ]    /* bitwise_and(x, 255) */
LOCAL_MEM_UPDATE_FROM_MIDDLE_TO_END:
    [ 544 := #buf(32, Y8) ]             /* memcpy(544 <- 384, 32) */
    [ 536 := #buf(32, {SLICE_LENGTH}) ] /* for slice(convert(y, bytes32), start=24, len=8) */
    [ 704 := #buf(32, {SLICE_LENGTH}) ++ #bufSeg(#buf(32, Y8), 24, {SLICE_LENGTH}) ]    /* return: bytes[8] */ /* memcpy(704 <- 536, 40) */
    {TO_LITTLE_ENDIAN_64_ZERO_PADDING}
+requires:
    // conditions
    andBool #range(0 <= #sizeWordStack(WS) <= 1000) // NOTE: rough bound
    andBool #rangeUInt(256, RETURN_ADDR)
    andBool #rangeUInt(256, VALUE)
    // let-bindings
    andBool X1 ==Int VALUE /Int 256
    andBool X2 ==Int X1    /Int 256
    andBool X3 ==Int X2    /Int 256
    andBool X4 ==Int X3    /Int 256
    andBool X5 ==Int X4    /Int 256
    andBool X6 ==Int X5    /Int 256
    andBool X7 ==Int X6    /Int 256
    andBool X8 ==Int X7    /Int 256
    //
    andBool Y1 ==Int                  VALUE &Int 255
    andBool Y2 ==Int (Y1 *Int 256) +Int (X1 &Int 255)
    andBool Y3 ==Int (Y2 *Int 256) +Int (X2 &Int 255)
    andBool Y4 ==Int (Y3 *Int 256) +Int (X3 &Int 255)
    andBool Y5 ==Int (Y4 *Int 256) +Int (X4 &Int 255)
    andBool Y6 ==Int (Y5 *Int 256) +Int (X5 &Int 255)
    andBool Y7 ==Int (Y6 *Int 256) +Int (X6 &Int 255)
    andBool Y8 ==Int (Y7 *Int 256) +Int (X7 &Int 255)
gas:         #symGas(G, 0 => {GAS_COST}, 0 => {GAS_COST}, .List, Cmem({SCHEDULE}, {MEMORY_USED}))
memory_used: #symMem(0 => {MEM_COST}, .Set)
GAS_COST: 7572
MEM_COST: 832

[to_little_endian_64-forloop]
pc: {PC_BEGIN} => {PC_MIDDLE}
word_stack: {WORD_STACK_BEGIN} => {WORD_STACK_MIDDLE}
local_mem: {LOCAL_MEM_BEGIN} => {LOCAL_MEM_MIDDLE}
;   ; save call stack args
;   [ 352 := #buf(32, RETURN_ADDR) ]
;   [ 320 := #buf(32, VALUE) ]
;   ; init locals
;   [ 384 := #buf(32, 0) ]                  /* y: uint256 = 0 */
;   [ 416 := #buf(32, VALUE) ]              /* x: uint256 = value */
;   [ 448 := #buf(32, 0) ]                  /* init for-loop index */
;   ; loop body (pc: 189 <-> 372)
;   [ 384 := #buf(32, 0) ]                  /* y = shift(y, 8) */ /* y << 8 */
;   [ 480 := #buf(32, VALUE &Int 255) ]     /* bitwise_and(x, 255) */
;   [ 384 := #buf(32, VALUE &Int 255) ]     /* y = y + bitwise_and(x, 255) */
;   [ 416 := #buf(32, VALUE /Int 256) ]     /* x = shift(x, -8) */ /* x >> 8 */
;   [ 448 := #buf(32, 1) ]                  /* increase for-loop index */
;   ; ... repeat loop body ...
gas: #symGas(G, 0, 0, .List, Cmem({SCHEDULE}, #symMem(0, .Set))) => _
memory_used: #symMem(0, .Set) => _

[to_little_endian_64-return]
pc: {PC_MIDDLE} => {PC_END}
word_stack: {WORD_STACK_MIDDLE} => {WORD_STACK_END}
local_mem: {LOCAL_MEM_MIDDLE} => {LOCAL_MEM_END}
;   [ 544 := #buf(32, Y8) ]                 /* memcpy 544 <- 384 */
;   [ 536 := #buf(32, 8) ]                  /* slice by overwrite */
;   [ 704 := #buf(32, 8) ++ #bufSeg(#buf(32, Y8), 24, 8)) ]         /* prepareing for return value*/
;
;   [ 800 := #buf(32, 8) ]
;   [ 744 <- 0 ]
;   [ 800 := #buf(32, 9) ]
;   [ 745 <- 0 ]
;   ...
;   [ 767 <- 0 ]                            /* padding */
;   [ 800 := #buf(32, 32) ]                 /* padding loop index */
;
;   [ 672 := #buf(32, 32) ]
;   [ 640 := #buf(32, 96) ]
;   [ 640 := #buf(32, 64) ]
;   [ 640 := #buf(32, 32) ]
;   [ 640 := #buf(32, 0) ]
gas: #symGas(G, 0, 0, .List, Cmem({SCHEDULE}, #symMem(0, .Set))) => _
memory_used: #symMem(0, .Set) => _

;
; get_deposit_root
;

[get_deposit_root]
; The term `#buf(EXTRA_CALL_DATA_SIZE, EXTRA_CALL_DATA)` models certain extra call-data added accidently or intentionally.
; This ensures that the function works correctly even in such a case.
call_data: #abiCallData("get_deposit_root", .TypedArgs) ++ #buf(EXTRA_CALL_DATA_SIZE, EXTRA_CALL_DATA)
storage: M
+requires:
    // conditions
    andBool CALL_VALUE ==Int 0
    // types
    andBool #rangeUInt(256, DEPOSIT_COUNT)
    andBool isStorage(M)
    // let-bindings
    andBool DEPOSIT_COUNT ==Int select(M, #hashedLocation({COMPILER}, {DEPOSIT_COUNT}, .IntList))
PC_LOOPENTER: 704
PC_LOOPHEAD: 975
PC_END: 1301
WORD_STACK_INIT: 32 : 416 : .WordStack
LOCAL_MEM_BEGIN: .Map
    ; function hash
    [  28 := 197 : 242 : 137 : 47 : #take(28, #buf(EXTRA_CALL_DATA_SIZE, EXTRA_CALL_DATA)) ]
    {VYPER_GENERATED_BOUNDS}
LOCAL_MEM_INIT: {LOCAL_MEM_BEGIN}
    ; locals
    [ 320 := #buf(32, 0) ]              /* zero_bytes32: bytes32 = 0x0 */
    [ 352 := #buf(32, 0) ]              /* node: bytes32 = zero_bytes32 */
    [ 384 := #buf(32, DEPOSIT_COUNT) ]  /* size: uint256 = self.deposit_count */
    [ 416 := #buf(32, 0) ]              /* height = 0 */

[get_deposit_root-init]
pc: 0 => {PC_LOOPENTER}
word_stack: .WordStack => {WORD_STACK_INIT}
local_mem: .Map => {LOCAL_MEM_INIT}
; gas usage = 417 = 375 + ( 42 = 3*n + n^2 / 512 where n = 14 = 448 / 32 )
gas:         #symGas(G, 0 => {GAS_COST}, 0 => {GAS_COST}, .List, Cmem({SCHEDULE}, {MEMORY_USED}))
memory_used: #symMem(0 => 448, .Set)
GAS_COST: 400

[get_deposit_root-loop0]
pc: {PC_LOOPENTER} => {PC_LOOPHEAD}
word_stack: {WORD_STACK_INIT} => 1 : {WORD_STACK_INIT}

[get_deposit_root-loop0-then]
local_mem: {LOCAL_MEM_INIT} => {LOCAL_MEM_INIT}
    [ 192 := #buf(32, 0) ]                              /* branch storage index = 0 */
    [ 608 := #buf(32, {BRANCH_0}) ]                     /* branch[0] */
    [ 640 := #buf(32, 0) ]                              /* node */
    [ 576 := #buf(32, 64) ]                             /* size of sha256 input */
    [ 192 := #buf(32, {NODE_1}) ]                       /* sha256 return value via sha256(608, 64) */
    [ 352 := #buf(32, {NODE_1}) ]                       /* update node = sha256(branch[0], node) */
    [ 384 := #buf(32, DEPOSIT_COUNT /Int 2) ]           /* update size */
    [ 416 := #buf(32, 1) ]                              /* update height */
BRANCH_0: select(M, #hashedLocation({COMPILER}, {BRANCH}, 0))
NODE_1: #sha256(#buf(32, {BRANCH_0}) ++ #buf(32, 0))
+requires:
    // conditions
    andBool DEPOSIT_COUNT &Int 1 ==Int 1
; gas usage = 1766 = 1703 + ( 63 = 3*n + n^2 / 512 where n = 21 = 672 / 32 )
gas:         #symGas(G, 0 => {GAS_COST}, 0 => {GAS_COST}, .List, Cmem({SCHEDULE}, {MEMORY_USED}))
memory_used: #symMem(448 => 672, .Set)
GAS_COST: 1328

[get_deposit_root-loop0-else]
local_mem: {LOCAL_MEM_INIT} => {LOCAL_MEM_INIT}
    [ 480 := #buf(32, 0) ]                              /* node */
    [ 192 := #buf(32, 2) ]                              /* zero_hashes storage index = 2 */
    [ 512 := #buf(32, {ZERO_HASHES_0}) ]                /* zero_hashes[0] */
    [ 448 := #buf(32, 64) ]                             /* size of sha256 input */
    [ 192 := #buf(32, {NODE_1}) ]                       /* sha256 return value via sha256(480, 64) */
    [ 352 := #buf(32, {NODE_1}) ]                       /* update node = sha256(node, zero_hashes[0]) */
    [ 384 := #buf(32, DEPOSIT_COUNT /Int 2) ]           /* update size */
    [ 416 := #buf(32, 1) ]                              /* update height */
ZERO_HASHES_0: select(M, #hashedLocation({COMPILER}, {ZERO_HASHES}, 0))
NODE_1: #sha256(#buf(32, 0) ++ #buf(32, {ZERO_HASHES_0}))
+requires:
    // conditions
    andBool DEPOSIT_COUNT &Int 1 =/=Int 1
; gas usage = 1744 = 1693 + ( 51 = 3*n + n^2 / 512 where n = 17 = 544 / 32 )
gas:         #symGas(G, 0 => {GAS_COST}, 0 => {GAS_COST}, .List, Cmem({SCHEDULE}, {MEMORY_USED}))
memory_used: #symMem(448 => 544, .Set)
GAS_COST: 1318

[get_deposit_root-loop]
; MEMORY_USED_LOOPHEAD: 17 or 21
LOCAL_MEM_LOOPHEAD: {LOCAL_MEM_BEGIN}
    ; locals
    [ 320 := #buf(32, 0) ]          /* zero_bytes32: bytes32 = 0x0 */
    [ 352 := #buf(32, NODE) ]       /* node: bytes32 */
    [ 384 := #buf(32, SIZE) ]       /* size: uint256 */
    [ 416 := #buf(32, HEIGHT) ]     /* height */
    ; garbages
    [ 192 := #buf(32, ANON_1) ]     /* sha256 return value */
    // for if-then branch
    [ 576 := #buf(32, ANON_2) ]     /* size of sha256 input */
    [ 608 := #buf(32, ANON_3) ]     /* branch[height] */
    [ 640 := #buf(32, ANON_4) ]     /* node */
    // for if-else branch
    [ 448 := #buf(32, ANON_5) ]     /* size of sha256 input */
    [ 480 := #buf(32, ANON_6) ]     /* node */
    [ 512 := #buf(32, ANON_7) ]     /* zero_hashes[height] */
+requires:
    // conditions
    andBool #range(0 <= HEIGHT <= 32)
    // types
    andBool #rangeUInt(256, NODE)
    andBool #rangeUInt(256, SIZE)
    andBool #rangeUInt(256, ANON_1)
    andBool #rangeUInt(256, ANON_2)
    andBool #rangeUInt(256, ANON_3)
    andBool #rangeUInt(256, ANON_4)
    andBool #rangeUInt(256, ANON_5)
    andBool #rangeUInt(256, ANON_6)
    andBool #rangeUInt(256, ANON_7)

[get_deposit_root-loop-body]
pc: {PC_LOOPHEAD}
word_stack: (HEIGHT => HEIGHT +Int 1) : {WORD_STACK_INIT}
+requires:
    // conditions
    andBool HEIGHT <Int 32

[get_deposit_root-loop-body-then]
local_mem: {LOCAL_MEM_LOOPHEAD} => {LOCAL_MEM_LOOPHEAD}
    [ 192 := #buf(32, 0) ]                      /* branch storage index = 0 */
    [ 608 := #buf(32, {BRANCH_HEIGHT}) ]        /* branch[height] */
    [ 640 := #buf(32, NODE) ]                   /* node */
    [ 576 := #buf(32, 64) ]                     /* size of sha256 input */
    [ 192 := #buf(32, {NODE_NEW}) ]             /* sha256 return value */
    [ 352 := #buf(32, {NODE_NEW}) ]             /* update node */
    [ 384 := #buf(32, SIZE /Int 2) ]            /* update size */
    [ 416 := #buf(32, HEIGHT +Int 1) ]          /* update height */
BRANCH_HEIGHT: select(M, #hashedLocation({COMPILER}, {BRANCH}, HEIGHT))
NODE_NEW: #sha256(#buf(32, {BRANCH_HEIGHT}) ++ #buf(32, NODE))
+requires:
    // conditions
    andBool SIZE &Int 1 ==Int 1
gas:         #symGas(G, 0 => {GAS_COST}, 0 => {GAS_COST}, .List, Cmem({SCHEDULE}, {MEMORY_USED}))
memory_used: #symMem(672, .Set)
GAS_COST: 1350

[get_deposit_root-loop-body-else]
local_mem: {LOCAL_MEM_LOOPHEAD} => {LOCAL_MEM_LOOPHEAD}
    [ 480 := #buf(32, NODE) ]                   /* node */
    [ 192 := #buf(32, 2) ]                      /* zero_hashes storage index = 2 */
    [ 512 := #buf(32, {ZERO_HASHES_HEIGHT}) ]   /* zero_hashes[height] */
    [ 448 := #buf(32, 64) ]                     /* size of sha256 input */
    [ 192 := #buf(32, {NODE_NEW}) ]             /* sha256 return value via sha256(480, 64) */
    [ 352 := #buf(32, {NODE_NEW}) ]             /* update node = sha256(node, zero_hashes[height]) */
    [ 384 := #buf(32, SIZE /Int 2) ]            /* update size = size / 2 */
    [ 416 := #buf(32, HEIGHT +Int 1) ]          /* update height = height + 1 */
ZERO_HASHES_HEIGHT: select(M, #hashedLocation({COMPILER}, {ZERO_HASHES}, HEIGHT))
NODE_NEW: #sha256(#buf(32, NODE) ++ #buf(32, {ZERO_HASHES_HEIGHT}))
+requires:
    // conditions
    andBool SIZE &Int 1 =/=Int 1
gas:         #symGas(G, 0 => {GAS_COST}, 0 => {GAS_COST}, .List, Cmem({SCHEDULE}, {MEMORY_USED}))
memory_used: #symMem(672, .Set)
GAS_COST: 1340

[get_deposit_root-loop-exit]
k: #execute => #halt
pc: {PC_LOOPHEAD} => {PC_END}
RETURN_VAL: #sha256(#buf(32, NODE) ++ #bufSeg(#buf(32, Y8), 24, 8) ++ #buf(24, 0))
output: _ => #buf(32, {RETURN_VAL})
word_stack: HEIGHT : {WORD_STACK_INIT} => .WordStack
local_mem: {LOCAL_MEM_LOOPHEAD} => {LOCAL_MEM_LOOPHEAD}
    ; preparing for calling to_little_endian_64
    [ 1152 := #buf(32, NODE) ]
    [  736 := #buf(32, 2154246793) ]            /* 0x80673289 */ /* ??? */
    [  768 := #buf(32, DEPOSIT_COUNT) ]
    ; call to_little_endian_64 (pc: 1013 -> [155 -> ... -> 628] -> 1014)
    {LOCAL_MEM_UPDATE_BY_TO_LITTLE_ENDIAN_64_DEPOSIT_COUNT}
    ; finish
    [  864 := #buf(32, 8) ]
    [  960 := #buf(32, 0) ]
    [  896 := #bufSeg(#buf(32, Y8), 24, 8) ++ #buf(24, 0) ]
    [  960 := #buf(32, 32) ]
    [  384 := #buf(32, SIZE) ]                  /* restore size: uint256 */
    [  352 := #buf(32, NODE) ]                  /* restore node: bytes32 */
    [  320 := #buf(32, 0) ]                     /* restore zero_bytes32: bytes32 */
    [ 1184 := #bufSeg(#buf(32, Y8), 24, 8) ]    /* self.to_little_endian_64(self.deposit_count) */  /* via memcpy(1152 <- 864,  8) */
    [ 1024 := #buf(32, 0) ]                     /* zero_bytes32 */                                  /* via memcpy( 992 <- 320, 32) */
    [  992 := #buf(32, 24) ]                    /* slice len */
    [ 1192 := #buf(24, 0) ]                     /* slice(zero_bytes32, start=0, len=24) */          /* via memcpy(1160 <- 992, 24) */
    [ 1120 := #buf(32, 64) ]
    [  192 := #buf(32, {RETURN_VAL}) ]          /* via sha256(1120, 64) */
    [    0 := #buf(32, {RETURN_VAL}) ]          /* return sha256(concat(node, self.to_little_endian_64(self.deposit_count), slice(zero_bytes32, start=0, len=24))) */
RETURN_ADDR_FROM_TO_LITTLE_ENDIAN_64: 1046
+requires:
    // conditions
    andBool HEIGHT ==Int 32
    {LET_BINDINGS_OF_TO_LITTLE_ENDIAN_64_DEPOSIT_COUNT}
gas:         #symGas(G, 0 => {GAS_COST}, 0 => {GAS_COST}, .List, Cmem({SCHEDULE}, {MEMORY_USED}))
memory_used: #symMem(672 => 1216, .Set)
GAS_COST: 11404

;
; get_deposit_count
;

[get_deposit_count]
; The term `#buf(EXTRA_CALL_DATA_SIZE, EXTRA_CALL_DATA)` models certain extra call-data added accidently or intentionally.
; This ensures that the function works correctly even in such a case.
call_data: #abiCallData("get_deposit_count", .TypedArgs) ++ #buf(EXTRA_CALL_DATA_SIZE, EXTRA_CALL_DATA)
storage: M
+requires:
    // conditions
    andBool CALL_VALUE ==Int 0
    // types
    andBool #rangeUInt(256, DEPOSIT_COUNT)
    andBool isStorage(M)
    // let-bindings
    andBool DEPOSIT_COUNT ==Int select(M, #hashedLocation({COMPILER}, {DEPOSIT_COUNT}, .IntList))
    {LET_BINDINGS_OF_TO_LITTLE_ENDIAN_64_DEPOSIT_COUNT}
LOCAL_MEM_BEGIN: .Map
    ; function hash
    [  28 := 98 : 31 : 209 : 48 : #take(28, #buf(EXTRA_CALL_DATA_SIZE, EXTRA_CALL_DATA)) ]
;   [  28 <-  98 ]
;   [  29 <-  31 ]
;   [  30 <- 209 ]
;   [  31 <-  48 ]
    {VYPER_GENERATED_BOUNDS}
k: #execute => #halt
pc: 0 => 1577
output: _ => #encodeArgs(#bytes(#bufSeg(#buf(32, Y8), 24, 8)))
; output: _ => #buf(32, 32) ++ #buf(32, 8) ++ #bufSeg(#buf(32, Y8), 24, 8) ++ #buf(24, 0)
;            ; 608             640            672                             680         704
word_stack: .WordStack
local_mem: .Map => {LOCAL_MEM_BEGIN}
    ; before call
    [ 320 := #buf(32, 2154246793) ]     /* 0x80673289 */ /* ??? */
    [ 352 := #buf(32, DEPOSIT_COUNT) ]
    ; call to_little_endian_64
    {LOCAL_MEM_UPDATE_BY_TO_LITTLE_ENDIAN_64_DEPOSIT_COUNT}
    ; after call
    [ 448 := #buf(32, 8) ]
    [ 544 := #buf(32, 0) ]
    [ 480 := #bufSeg(#buf(32, Y8), 24, 8) ++ #buf(24, 0) ]  /* return value from to_little_endian_64 */
    [ 544 := #buf(32, 32) ]
    [ 640 := #buf(32, 8) ++ #bufSeg(#buf(32, Y8), 24, 8) ]  /* memcpy(640 <- 448, 40) */
    [ 736 := #buf(32, 32) ]                                 /* zero padding loop index */
    [ 680 <- 0 ]                                            /* zero padding */
    [ 681 <- 0 ]
    [ 682 <- 0 ]
    [ 683 <- 0 ]
    [ 684 <- 0 ]
    [ 685 <- 0 ]
    [ 686 <- 0 ]
    [ 687 <- 0 ]
    [ 688 <- 0 ]
    [ 689 <- 0 ]
    [ 690 <- 0 ]
    [ 691 <- 0 ]
    [ 692 <- 0 ]
    [ 693 <- 0 ]
    [ 694 <- 0 ]
    [ 695 <- 0 ]
    [ 696 <- 0 ]
    [ 697 <- 0 ]
    [ 698 <- 0 ]
    [ 699 <- 0 ]
    [ 700 <- 0 ]
    [ 701 <- 0 ]
    [ 702 <- 0 ]
    [ 703 <- 0 ]
    [ 608 := #buf(32, 32) ]                                 /* return(608, 96) */
RETURN_ADDR_FROM_TO_LITTLE_ENDIAN_64: 1358
gas:         #symGas(G, 0 => {GAS_COST}, 0 => {GAS_COST}, .List, Cmem({SCHEDULE}, {MEMORY_USED}))
memory_used: #symMem(0 => 832, .Set)
GAS_COST: 11455

;
; deposit
;

[deposit]
; #buf(32, 96) ++ #buf(32, 192) ++ #buf(32, 256)        // header
; ++ #buf(32, 48) ++ #buf(48, PUBKEY) ++ #buf(16, 0)    // pubkey + zero-padding
; ++ #buf(32, 32) ++ #buf(32, WITHDRAWAL_CREDENTIALS)   // withdrawal_credentials
; ++ #buf(32, 96) ++ #buf(96, SIGNATURE)                // signature
call_data: #abiCallData("deposit", (
            #bytes(#buf({PUBKEY_LENGTH},                 PUBKEY)),
            #bytes(#buf({WITHDRAWAL_CREDENTIALS_LENGTH}, WITHDRAWAL_CREDENTIALS)),
            #bytes(#buf({SIGNATURE_LENGTH},              SIGNATURE)),
            #bytes32(DEPOSIT_DATA_ROOT) ))
storage: M
+requires:
    // ranges
    andBool #range(0 <= PUBKEY                 < 2 ^Int ({PUBKEY_LENGTH}                 *Int 8))
    andBool #range(0 <= WITHDRAWAL_CREDENTIALS < 2 ^Int ({WITHDRAWAL_CREDENTIALS_LENGTH} *Int 8))
    andBool #range(0 <= SIGNATURE              < 2 ^Int ({SIGNATURE_LENGTH}              *Int 8))
    andBool #rangeUInt(256, DEPOSIT_DATA_ROOT)
    // types
    andBool #rangeUInt(256, DEPOSIT_COUNT)
    andBool isStorage(M)
    // let-bindings
    andBool DEPOSIT_COUNT ==Int select(M, #hashedLocation({COMPILER}, {DEPOSIT_COUNT}, .IntList))
    {LET_BINDINGS_OF_TO_LITTLE_ENDIAN_64_DEPOSIT_COUNT}
    {LET_BINDINGS_OF_TO_LITTLE_ENDIAN_64_DEPOSIT_AMOUNT}
    // conditions
    {CONDITIONS}
CONDITIONS:
    andBool DEPOSIT_COUNT <Int {MAX_DEPOSIT_COUNT}
    andBool CALL_VALUE /Int {GWEI_IN_WEI} >=Int {MIN_DEPOSIT_AMOUNT}
PUBKEY_LENGTH:                 48
WITHDRAWAL_CREDENTIALS_LENGTH: 32
SIGNATURE_LENGTH:              96
MAX_DEPOSIT_COUNT:  4294967295
GWEI_IN_WEI:        1000000000
MIN_DEPOSIT_AMOUNT: 1000000000
DEPOSIT_AMOUNT: (CALL_VALUE /Int {GWEI_IN_WEI})
LOCAL_MEM_BEGIN: .Map
    {LOCAL_MEM_DEPOSIT_FUNCTION_HASH}
    {VYPER_GENERATED_BOUNDS}
LOCAL_MEM_DEPOSIT_FUNCTION_HASH:
    ; function hash
    [  28 <-  34 ]
    [  29 <- 137 ]
    [  30 <-  81 ]
    [  31 <-  24 ]
LOCAL_MEM_INIT: {LOCAL_MEM_BEGIN}
    ; load calldata
    [  320 := #buf(32, 48) ++ #buf(48, PUBKEY) ]                    /* calldatacopy(416, 100,  80) */
    [  448 := #buf(32, 32) ++ #buf(32, WITHDRAWAL_CREDENTIALS) ]    /* calldatacopy(544, 196,  64) */
    [  544 := #buf(32, 96) ++ #buf(96, SIGNATURE) ]                 /* calldatacopy(640, 260, 128) */
    [  736 := #buf(32, {GWEI_IN_WEI}) ]                             /* 1 gwei = 10^9 wei */
    [  704 := #buf(32, {DEPOSIT_AMOUNT}) ]                          /* deposit_amount: uint256 = msg.value / as_wei_value(1, "gwei") */
LOCAL_MEM_SUBCALL_1: {LOCAL_MEM_INIT}
    ; before call
    [  864 := #buf(32, 288) ]                                       /* memcpy loop index */
    [  896 := #buf(32, 2154246793) ]                                /* ??? */
    [  928 := #buf(32, {DEPOSIT_AMOUNT}) ]
    ; call to_little_endian_64
    {LOCAL_MEM_UPDATE_BY_TO_LITTLE_ENDIAN_64_DEPOSIT_AMOUNT}
    ; after call
    [ 1024 := #buf(32, 8) ]
    [ 1120 := #buf(32, 0) ]
    [ 1056 := #bufSeg(#buf(32, YY8), 24, 8) ++ #buf(24, 0) ]
    [ 1120 := #buf(32, 32) ]
    ; restore stack
    [  832 := #buf(32, 0) ]
    [  800 := #buf(32, 0) ]
    [  768 := #buf(32, 0) ]
    [  736 := #buf(32, {GWEI_IN_WEI}) ]
    [  704 := #buf(32, {DEPOSIT_AMOUNT}) ]
    [  672 := #buf(32, 0) ]
    [  640 := #bufSeg(#buf(96, SIGNATURE), 64, 32) ]
    [  608 := #bufSeg(#buf(96, SIGNATURE), 32, 32) ]
    [  576 := #bufSeg(#buf(96, SIGNATURE),  0, 32) ]
    [  544 := #buf(32, 96) ]
    [  512 := #buf(32, 0) ]
    [  480 := #buf(32, WITHDRAWAL_CREDENTIALS) ]
    [  448 := #buf(32, 32) ]
    [  416 := #buf(32, 0) ]
    [  384 := #bufSeg(#buf(48, PUBKEY), 32, 16) ++ #buf(16, 0) ]
    [  352 := #bufSeg(#buf(48, PUBKEY),  0, 32) ]
    [  320 := #buf(32, 48) ]
    ; copy result
    [  768 := #buf(32, 8) ++ #bufSeg(#buf(32, YY8), 24, 8) ]    /* memcpy(768 <- 1024, 40) */ /* amount: bytes[8] = self.to_little_endian_64(deposit_amount) */
LOCAL_MEM_SUBCALL_2: {LOCAL_MEM_SUBCALL_1}
    ; before call
    [ 1152 := #buf(32, 288) ]                                       /* memcpy loop index */
    [ 1184 := #buf(32, 2154246793) ]                                /* ??? */
    [ 1216 := #buf(32, DEPOSIT_COUNT) ]
    ; call to_little_endian_64
    {LOCAL_MEM_UPDATE_BY_TO_LITTLE_ENDIAN_64_DEPOSIT_COUNT}
    ; after call
    [ 1312 := #buf(32, 8) ]
    [ 1408 := #buf(32, 0) ]
    [ 1344 := #bufSeg(#buf(32, Y8), 24, 8) ++ #buf(24, 0) ]
    [ 1408 := #buf(32, 32) ]
    ; restore stack
    [ 1120 := #buf(32, 32) ]
    [ 1088 := #buf(32, 0) ]
    [ 1056 := #bufSeg(#buf(32, YY8), 24, 8) ++ #buf(24, 0) ]
    [ 1024 := #buf(32, 8) ]
    [  992 := #buf(32, 0) ]
    [  960 := #buf(32, 0) ]
    [  928 := #buf(32, {DEPOSIT_AMOUNT}) ]
    [  896 := #buf(32, 2154246793) ]
    [  864 := #buf(32, 288) ]
    [  832 := #buf(32, 0) ]
    [  800 := #bufSeg(#buf(32, YY8), 24, 8) ++ #buf(24, 0) ]
    [  768 := #buf(32, 8) ]
    [  736 := #buf(32, {GWEI_IN_WEI}) ]
    [  704 := #buf(32, {DEPOSIT_AMOUNT}) ]
    [  672 := #buf(32, 0) ]
    [  640 := #bufSeg(#buf(96, SIGNATURE), 64, 32) ]
    [  608 := #bufSeg(#buf(96, SIGNATURE), 32, 32) ]
    [  576 := #bufSeg(#buf(96, SIGNATURE),  0, 32) ]
    [  544 := #buf(32, 96) ]
    [  512 := #buf(32, 0) ]
    [  480 := #buf(32, WITHDRAWAL_CREDENTIALS) ]
    [  448 := #buf(32, 32) ]
    [  416 := #buf(32, 0) ]
    [  384 := #bufSeg(#buf(48, PUBKEY), 32, 16) ++ #buf(16, 0) ]
    [  352 := #bufSeg(#buf(48, PUBKEY),  0, 32) ]
    [  320 := #buf(32, 48) ]
    ; copy result
    [ 1440 := #buf(32, 8) ++ #bufSeg(#buf(32, Y8), 24, 8) ] /* memcpy(1440 <- 1312, 40) */
RETURN_ADDR_FROM_TO_LITTLE_ENDIAN_64_DEPOSIT_AMOUNT: 1880
RETURN_ADDR_FROM_TO_LITTLE_ENDIAN_64:                2102
LOCAL_MEM_LOG: {LOCAL_MEM_SUBCALL_2}
    [ 1568 := #buf(32, 160) ]                                       /* offset pointer */
    [ 1632 := #buf(32, 160) ]                                       /* offset to pubkey */
    [ 1792 := #buf(32, 48) ++ #buf(48, PUBKEY) ]                    /* pubkey */ /* memcpy(1792 <- 320, 80) */
    [ 1536 := #buf(32, 64) ]                                        /* padding index */
    [ 1872 <- 0 ]
    [ 1873 <- 0 ]
    [ 1874 <- 0 ]
    [ 1875 <- 0 ]
    [ 1876 <- 0 ]
    [ 1877 <- 0 ]
    [ 1878 <- 0 ]
    [ 1879 <- 0 ]
    [ 1880 <- 0 ]
    [ 1881 <- 0 ]
    [ 1882 <- 0 ]
    [ 1883 <- 0 ]
    [ 1884 <- 0 ]
    [ 1885 <- 0 ]
    [ 1886 <- 0 ]
    [ 1887 <- 0 ]
    [ 1568 := #buf(32, 256) ]
    [ 1664 := #buf(32, 256) ]                                       /* offset to withdrawal_credentials */
    [ 1888 := #buf(32, 32) ++ #buf(32, WITHDRAWAL_CREDENTIALS) ]    /* withdrawal_credentials */ /* memcpy(1888 <- 448, 64) */
    [ 1536 := #buf(32, 32) ]                                        /* padding index */
    [ 1568 := #buf(32, 320) ]
    [ 1696 := #buf(32, 320) ]                                       /* offset to amount */
    [ 1952 := #buf(32, 8) ++ #bufSeg(#buf(32, YY8), 24, 8) ]        /* amount */ /* memcpy(1952 <- 768, 40) */
    [ 1536 := #buf(32, 32) ]                                        /* padding index */
    [ 1992 <- 0 ]
    [ 1993 <- 0 ]
    [ 1994 <- 0 ]
    [ 1995 <- 0 ]
    [ 1996 <- 0 ]
    [ 1997 <- 0 ]
    [ 1998 <- 0 ]
    [ 1999 <- 0 ]
    [ 2000 <- 0 ]
    [ 2001 <- 0 ]
    [ 2002 <- 0 ]
    [ 2003 <- 0 ]
    [ 2004 <- 0 ]
    [ 2005 <- 0 ]
    [ 2006 <- 0 ]
    [ 2007 <- 0 ]
    [ 2008 <- 0 ]
    [ 2009 <- 0 ]
    [ 2010 <- 0 ]
    [ 2011 <- 0 ]
    [ 2012 <- 0 ]
    [ 2013 <- 0 ]
    [ 2014 <- 0 ]
    [ 2015 <- 0 ]
    [ 1568 := #buf(32, 384) ]
    [ 1728 := #buf(32, 384) ]                                       /* offset to signature */
    [ 2016 := #buf(32, 96) ++ #buf(96, SIGNATURE) ]                 /* signature */ /* memcpy(<- 544, 128) */
    [ 1536 := #buf(32, 96) ]                                        /* padding index */
    [ 1568 := #buf(32, 512) ]
    [ 1760 := #buf(32, 512) ]                                       /* offset to deposit_count */
    [ 2144 := #buf(32, 8) ++ #bufSeg(#buf(32, Y8), 24, 8) ]         /* deposit_count */ /* memcpy(<- 1440, 40) */
    [ 1536 := #buf(32, 32) ]                                        /* padding index */
    [ 2184 <- 0 ]
    [ 2185 <- 0 ]
    [ 2186 <- 0 ]
    [ 2187 <- 0 ]
    [ 2188 <- 0 ]
    [ 2189 <- 0 ]
    [ 2190 <- 0 ]
    [ 2191 <- 0 ]
    [ 2192 <- 0 ]
    [ 2193 <- 0 ]
    [ 2194 <- 0 ]
    [ 2195 <- 0 ]
    [ 2196 <- 0 ]
    [ 2197 <- 0 ]
    [ 2198 <- 0 ]
    [ 2199 <- 0 ]
    [ 2200 <- 0 ]
    [ 2201 <- 0 ]
    [ 2202 <- 0 ]
    [ 2203 <- 0 ]
    [ 2204 <- 0 ]
    [ 2205 <- 0 ]
    [ 2206 <- 0 ]
    [ 2207 <- 0 ]
    [ 1568 := #buf(32, 576) ]                                       /* offset pointer = size of log data */
LOCAL_MEM_LOG_ABSTRACT: MEM
    {LOCAL_MEM_DEPOSIT_FUNCTION_HASH}
    {VYPER_GENERATED_BOUNDS}
    ; function arguments and locals
    [  416 := #buf(32, 48) ++ #buf(48, PUBKEY) ]                    /* def deposit(pubkey: bytes[PUBKEY_LENGTH],                                    */
    [  496 := #buf(16, 0) ]
    [  512 := #buf(32, 0) ]
    [  544 := #buf(32, 32) ++ #buf(32, WITHDRAWAL_CREDENTIALS) ]    /*             withdrawal_credentials: bytes[WITHDRAWAL_CREDENTIALS_LENGTH],    */
    [  608 := #buf(32, 0) ]
    [  640 := #buf(32, 96) ++ #buf(96, SIGNATURE) ]                 /*             signature: bytes[SIGNATURE_LENGTH]):                             */
    [  768 := #buf(32, 0) ]
    [  800 := #buf(32, {DEPOSIT_AMOUNT}) ]                          /*     deposit_amount: uint256 = msg.value / as_wei_value(1, "gwei")            */
    [  832 := #buf(32, {GWEI_IN_WEI}) ]
    [  864 := #buf(32, 8) ++ #bufSeg(#buf(32, YY8), 24, 8) ]        /*     amount: bytes[8] = self.to_little_endian_64(deposit_amount)              */
    [  904 := #buf(24, 0) ]
LOCAL_MEM_DATA: {LOCAL_MEM_LOG}
    [ 1792 := #buf(32, 0) ]                             /* zero_bytes32: bytes32 = 0x0000000000000000000000000000000000000000000000000000000000000000 */
    ; compute pubkey_root
    [ 2016 := #buf(48, PUBKEY) ]                        /* memcpy(<- 352, 48) */
    [ 1888 := #buf(32, 0) ]                             /* memcpy(<- 1792, 32) */
    [ 1856 := #buf(32, 16) ]                            /* len=64 - PUBKEY_LENGTH */
    [ 2064 := #buf(16, 0) ]                             /* memcpy(<- 1888, 16) */
    [ 1984 := #buf(32, 64) ]
    [  192 := #buf(32, {PUBKEY_ROOT}) ]                 /* sha256(2016, 64) */
    [ 1824 := #buf(32, {PUBKEY_ROOT}) ]                 /* pubkey_root: bytes32 = sha256(concat(pubkey, slice(zero_bytes32, start=0, len=64 - PUBKEY_LENGTH))) */
    ; compute tmp1
    [ 2176 := #buf(96, SIGNATURE) ]                     /* memcpy(<- 576, 96) */
    [ 2144 := #buf(32, 64) ]
    [  192 := #buf(32, {TMP1}) ]                        /* sha256(2176, 64) */
    [ 2688 := #buf(32, {TMP1}) ]                        /* sha256(slice(signature, start=0, len=64)), */
    ; compute tmp2
    [ 2368 := #bufSeg(#buf(96, SIGNATURE), 64, 32) ++ #buf(32, 0) ++ #buf(32, {DEPOSIT_AMOUNT}) ]   /* memcpy(<- 640, 96) */   /* TODO: ??? */
    [ 2336 := #buf(32, 32) ]                            /* len=SIGNATURE_LENGTH - 64 */
    [ 2560 := #bufSeg(#buf(96, SIGNATURE), 64, 32) ]    /* memcpy(<- 2368, 32) */
    [ 2592 := #buf(32, 0) ]
    [ 2528 := #buf(32, 64) ]
    [  192 := #buf(32, {TMP2}) ]                        /* sha256(2560, 64) */
    [ 2720 := #buf(32, {TMP2}) ]                        /* sha256(concat(slice(signature, start=64, len=SIGNATURE_LENGTH - 64), zero_bytes32)), */
    ; compute signature_root
    [ 2656 := #buf(32, 64) ]
    [  192 := #buf(32, {SIGNATURE_ROOT}) ]              /* sha256(2688, 64) */
    [ 2112 := #buf(32, {SIGNATURE_ROOT}) ]              /* signature_root: bytes32 = sha256(concat(...)) */
    ; compute tmp3
    [ 2848 := #buf(32, {PUBKEY_ROOT}) ]
    [ 2880 := #buf(32, WITHDRAWAL_CREDENTIALS) ]        /* memcpy(<- 480, 32) */
    [ 2816 := #buf(32, 64) ]
    [  192 := #buf(32, {TMP3}) ]                        /* sha256(2848, 64) */
    [ 3232 := #buf(32, {TMP3}) ]                        /* sha256(concat(pubkey_root, withdrawal_credentials)), */
    ; compute tmp4
    [ 3104 := #bufSeg(#buf(32, YY8), 24, 8) ]           /* memcpy(<- 800, 8) */
    [ 2976 := #buf(32, 0) ]                             /* memcpy(<- 1792, 32) */
    [ 2944 := #buf(32, 24) ]                            /* len=32 - AMOUNT_LENGTH */
    [ 3112 := #buf(24, 0) ]                             /* memcpy(<- 2976, 24) */
    [ 3136 := #buf(32, {SIGNATURE_ROOT}) ]
    [ 3072 := #buf(32, 64) ]
    [  192 := #buf(32, {TMP4}) ]                        /* sha256(3104, 64) */
    [ 3264 := #buf(32, {TMP4}) ]                        /* sha256(concat(amount, slice(zero_bytes32, start=0, len=32 - AMOUNT_LENGTH), signature_root)), */
    ; compute node
    [ 3200 := #buf(32, 64) ]
    [  192 := #buf(32, {NODE}) ]                        /* sha256(3232, 64) */
    [ 2784 := #buf(32, {NODE}) ]                        /* node: bytes32 = sha256(concat(...)) */
PUBKEY_ROOT: #sha256(#buf(48, PUBKEY) ++ #buf(16, 0))
TMP1: #sha256(#bufSeg(#buf(96, SIGNATURE), 0, 64))
TMP2: #sha256(#bufSeg(#buf(96, SIGNATURE), 64, 32) ++ #buf(32, 0))
SIGNATURE_ROOT: #sha256(#buf(32, {TMP1}) ++ #buf(32, {TMP2}))
TMP3: #sha256(#buf(32, {PUBKEY_ROOT}) ++ #buf(32, WITHDRAWAL_CREDENTIALS))
TMP4: #sha256(#bufSeg(#buf(32, YY8), 24, 8) ++ #buf(24, 0) ++ #buf(32, {SIGNATURE_ROOT}))
NODE: #sha256(#buf(32, {TMP3}) ++ #buf(32, {TMP4}))
PC_SUBCALL_1:    1808
PC_SUBCALL_2:    2032
PC_LOG:          2254
PC_DATA:         3201
PC_ADD_BEGIN:    4088
PC_ADD_LOOPHEAD: 4328
PC_ADD_END:      4338
MU_INIT:          768
MU_SUBCALL_1:    1152
MU_SUBCALL_2:    1480
MU_LOG:          2208
MU_DATA:         3296
MU_ADD_ODD:      3392
MU_ADD_EVEN:     3488

; @payable
; @public
; def deposit(pubkey: bytes[PUBKEY_LENGTH],
;             withdrawal_credentials: bytes[WITHDRAWAL_CREDENTIALS_LENGTH],
;             signature: bytes[SIGNATURE_LENGTH],
;             deposit_data_root: bytes32):
;
;     # Avoid overflowing the Merkle tree (and prevent edge case in computing `self.branch`)
;     assert self.deposit_count < MAX_DEPOSIT_COUNT
;
;     # Validate deposit data
;     deposit_amount: uint256 = msg.value / as_wei_value(1, "gwei")
;     assert deposit_amount >= MIN_DEPOSIT_AMOUNT
;     assert len(pubkey) == PUBKEY_LENGTH
;     assert len(withdrawal_credentials) == WITHDRAWAL_CREDENTIALS_LENGTH
;     assert len(signature) == SIGNATURE_LENGTH

[deposit-init]
pc: 0 => {PC_SUBCALL_1}
word_stack: .WordStack
local_mem: .Map => {LOCAL_MEM_INIT}
; gas usage = 765 + ( 82 = 3*n + n^2 / 512 where n = 27 = 864 / 32 )
gas:         #symGas(G, 0 => {GAS_COST}, 0 => {GAS_COST}, .List, Cmem({SCHEDULE}, {MEMORY_USED}))
memory_used: #symMem(0 => {MU_INIT}, .Set)
GAS_COST: 769

[deposit-init-revert-1]
k: #execute => #halt
status_code: _ => EVMC_REVERT
pc: 0 => 1707
word_stack: .WordStack => _
local_mem: .Map => _
CONDITIONS:
    // conditions
    andBool DEPOSIT_COUNT >=Int {MAX_DEPOSIT_COUNT}
gas:         #symGas(G, 0 => {GAS_COST}, 0 => {GAS_COST}, .List, Cmem({SCHEDULE}, {MEMORY_USED}))
memory_used: #symMem(0 => {MEM_COST}, .Set)
GAS_COST: 620
MEM_COST: 672

[deposit-init-revert-2]
k: #execute => #halt
status_code: _ => EVMC_REVERT
pc: 0 => 1759
word_stack: .WordStack => _
local_mem: .Map => _
CONDITIONS:
    // conditions
    andBool DEPOSIT_COUNT <Int {MAX_DEPOSIT_COUNT}
    andBool CALL_VALUE /Int {GWEI_IN_WEI} <Int {MIN_DEPOSIT_AMOUNT}
gas:         #symGas(G, 0 => {GAS_COST}, 0 => {GAS_COST}, .List, Cmem({SCHEDULE}, {MEMORY_USED}))
memory_used: #symMem(0 => {MEM_COST}, .Set)
GAS_COST: 697
MEM_COST: 768

; without calldata well-formedness condition

[deposit-init-calldata]
call_data: #buf(CALL_DATA_SIZE, CALL_DATA)
LOCAL_MEM_DEPOSIT_FUNCTION_HASH:
    [   28 := {CALLDATALOAD_0} ]
LOCAL_MEM_INIT: {LOCAL_MEM_BEGIN}
    ; load calldata
    [  320 := {PUBKEY_ARRAY} ]
    [  448 := {WITHDRAWAL_CREDENTIALS_ARRAY} ]
    [  544 := {SIGNATURE_ARRAY} ]
    [  736 := #buf(32, {GWEI_IN_WEI}) ]                             /* 1 gwei = 10^9 wei */
    [  704 := #buf(32, {DEPOSIT_AMOUNT}) ]                          /* deposit_amount: uint256 = msg.value / as_wei_value(1, "gwei") */
+requires:
    // conditions
    andBool {FUNCTION_SELECTOR} ==Int 579424536 /* 0x22895118 deposit */
    andBool CALL_DATA_SIZE >=Int 4
    {LENGTH_CHECK}
LENGTH_CHECK:
    andBool {PUBKEY_ARRAY_SIZE}                 ==Int {PUBKEY_LENGTH}
    andBool {WITHDRAWAL_CREDENTIALS_ARRAY_SIZE} ==Int {WITHDRAWAL_CREDENTIALS_LENGTH}
    andBool {SIGNATURE_ARRAY_SIZE}              ==Int {SIGNATURE_LENGTH}
CALLDATALOAD_0: #take(32, {CALL_DATA})
FUNCTION_SELECTOR: #asWord(#take(4, {CALLDATALOAD_0}))
;
PUBKEY_OFFSET:                 (4 +Word #asWord(#take(32, #drop( 4, {CALL_DATA}))))
WITHDRAWAL_CREDENTIALS_OFFSET: (4 +Word #asWord(#take(32, #drop(36, {CALL_DATA}))))
SIGNATURE_OFFSET:              (4 +Word #asWord(#take(32, #drop(68, {CALL_DATA}))))
;
PUBKEY_ARRAY:                 #take(32 +Int {PUBKEY_LENGTH},                 #drop({PUBKEY_OFFSET},                 {CALL_DATA}))
WITHDRAWAL_CREDENTIALS_ARRAY: #take(32 +Int {WITHDRAWAL_CREDENTIALS_LENGTH}, #drop({WITHDRAWAL_CREDENTIALS_OFFSET}, {CALL_DATA}))
SIGNATURE_ARRAY:              #take(32 +Int {SIGNATURE_LENGTH},              #drop({SIGNATURE_OFFSET},              {CALL_DATA}))
;
PUBKEY_ARRAY_SIZE:                 #asWord(#take(32, {PUBKEY_ARRAY}))
WITHDRAWAL_CREDENTIALS_ARRAY_SIZE: #asWord(#take(32, {WITHDRAWAL_CREDENTIALS_ARRAY}))
SIGNATURE_ARRAY_SIZE:              #asWord(#take(32, {SIGNATURE_ARRAY}))

[deposit-init-calldata-revert]
k: #execute => #halt
status_code: _ => EVMC_REVERT
word_stack: .WordStack => _
local_mem: .Map => _
gas:         #symGas(G, 0 => {GAS_COST}, 0 => {GAS_COST}, .List, Cmem({SCHEDULE}, {MEMORY_USED}))
memory_used: #symMem(0 => {MEM_COST}, .Set)

[deposit-init-calldata-revert-1]
pc: 0 => 1625
LENGTH_CHECK:
    andBool {PUBKEY_ARRAY_SIZE}                   >Int {PUBKEY_LENGTH}
GAS_COST: 261
MEM_COST: 400

[deposit-init-calldata-revert-2]
pc: 0 => 1657
LENGTH_CHECK:
    andBool {PUBKEY_ARRAY_SIZE}                  <=Int {PUBKEY_LENGTH}
    andBool {WITHDRAWAL_CREDENTIALS_ARRAY_SIZE}   >Int {WITHDRAWAL_CREDENTIALS_LENGTH}
GAS_COST: 326
MEM_COST: 512

[deposit-init-calldata-revert-3]
pc: 0 => 1689
LENGTH_CHECK:
    andBool {PUBKEY_ARRAY_SIZE}                  <=Int {PUBKEY_LENGTH}
    andBool {WITHDRAWAL_CREDENTIALS_ARRAY_SIZE}  <=Int {WITHDRAWAL_CREDENTIALS_LENGTH}
    andBool {SIGNATURE_ARRAY_SIZE}                >Int {SIGNATURE_LENGTH}
GAS_COST: 397
MEM_COST: 672

[deposit-init-calldata-revert-4]
pc: 0 => 1775
LENGTH_CHECK:
    andBool {PUBKEY_ARRAY_SIZE}                  <=Int {PUBKEY_LENGTH}
    andBool {WITHDRAWAL_CREDENTIALS_ARRAY_SIZE}  <=Int {WITHDRAWAL_CREDENTIALS_LENGTH}
    andBool {SIGNATURE_ARRAY_SIZE}               <=Int {SIGNATURE_LENGTH}
    andBool {PUBKEY_ARRAY_SIZE}                 =/=Int {PUBKEY_LENGTH}
GAS_COST: 723
MEM_COST: 768

[deposit-init-calldata-revert-5]
pc: 0 => 1791
LENGTH_CHECK:
    andBool {PUBKEY_ARRAY_SIZE}                  <=Int {PUBKEY_LENGTH}
    andBool {WITHDRAWAL_CREDENTIALS_ARRAY_SIZE}  <=Int {WITHDRAWAL_CREDENTIALS_LENGTH}
    andBool {SIGNATURE_ARRAY_SIZE}               <=Int {SIGNATURE_LENGTH}
    andBool {PUBKEY_ARRAY_SIZE}                  ==Int {PUBKEY_LENGTH}
    andBool {WITHDRAWAL_CREDENTIALS_ARRAY_SIZE} =/=Int {WITHDRAWAL_CREDENTIALS_LENGTH}
GAS_COST: 749
MEM_COST: 768

[deposit-init-calldata-revert-6]
pc: 0 => 1807
LENGTH_CHECK:
    andBool {PUBKEY_ARRAY_SIZE}                  <=Int {PUBKEY_LENGTH}
    andBool {WITHDRAWAL_CREDENTIALS_ARRAY_SIZE}  <=Int {WITHDRAWAL_CREDENTIALS_LENGTH}
    andBool {SIGNATURE_ARRAY_SIZE}               <=Int {SIGNATURE_LENGTH}
    andBool {PUBKEY_ARRAY_SIZE}                  ==Int {PUBKEY_LENGTH}
    andBool {WITHDRAWAL_CREDENTIALS_ARRAY_SIZE}  ==Int {WITHDRAWAL_CREDENTIALS_LENGTH}
    andBool {SIGNATURE_ARRAY_SIZE}              =/=Int {SIGNATURE_LENGTH}
GAS_COST: 775
MEM_COST: 768

;    # Emit `DepositEvent` log
;    amount: bytes[8] = self.to_little_endian_64(deposit_amount)
;    log.DepositEvent(pubkey, withdrawal_credentials, amount, signature, self.to_little_endian_64(self.deposit_count))

[deposit-subcall_1]
pc: {PC_SUBCALL_1} => {PC_SUBCALL_2}
word_stack: .WordStack
local_mem: {LOCAL_MEM_INIT} => {LOCAL_MEM_SUBCALL_1}
gas:         #symGas(G, 0 => {GAS_COST}, 0 => {GAS_COST}, .List, Cmem({SCHEDULE}, {MEMORY_USED}))
memory_used: #symMem({MU_INIT} => {MU_SUBCALL_1}, .Set)
GAS_COST: 10956

[deposit-subcall_2]
pc: {PC_SUBCALL_2} => {PC_LOG}
word_stack: .WordStack
local_mem: {LOCAL_MEM_SUBCALL_1} => {LOCAL_MEM_SUBCALL_2}
gas:         #symGas(G, 0 => {GAS_COST}, 0 => {GAS_COST}, .List, Cmem({SCHEDULE}, {MEMORY_USED}))
memory_used: #symMem({MU_SUBCALL_1} => {MU_SUBCALL_2}, .Set)
GAS_COST: 12385

[deposit-log]
pc: {PC_LOG} => {PC_DATA}
word_stack: .WordStack
local_mem: {LOCAL_MEM_SUBCALL_2} => {LOCAL_MEM_LOG}
gas:         #symGas(G, 0 => {GAS_COST}, 0 => {GAS_COST}, .List, Cmem({SCHEDULE}, {MEMORY_USED}))
memory_used: #symMem({MU_SUBCALL_2} => {MU_LOG}, .Set)
GAS_COST: 17104
log: _:List ( .List => ListItem(#abiEventLog(THIS, "DepositEvent",
            #bytes(#buf({PUBKEY_LENGTH}, PUBKEY)),
            #bytes(#buf({WITHDRAWAL_CREDENTIALS_LENGTH}, WITHDRAWAL_CREDENTIALS)),
            #bytes(#bufSeg(#buf(32, YY8), 24, 8)),
            #bytes(#buf({SIGNATURE_LENGTH}, SIGNATURE)),
            #bytes(#bufSeg(#buf(32, Y8), 24, 8)) )))
; log: _:List ( .List => ListItem({ THIS
;                                 | ListItem(45506446345753628416285423056165511379837572639148407563471291220684748896453) /* keccak256("DepositEvent(bytes,bytes,bytes,bytes,bytes)") */
;                                 |  #buf(32, 5 *Int 32)
;                                 ++ #buf(32, 5 *Int 32 +Int 96)
;                                 ++ #buf(32, 5 *Int 32 +Int 96 +Int 64)
;                                 ++ #buf(32, 5 *Int 32 +Int 96 +Int 64 +Int 64)
;                                 ++ #buf(32, 5 *Int 32 +Int 96 +Int 64 +Int 64 +Int 128)
;                                 ++ #buf(32, {PUBKEY_LENGTH})                 ++ #buf({PUBKEY_LENGTH}, PUBKEY) ++ #buf(16, 0)
;                                 ++ #buf(32, {WITHDRAWAL_CREDENTIALS_LENGTH}) ++ #buf({WITHDRAWAL_CREDENTIALS_LENGTH}, WITHDRAWAL_CREDENTIALS)
;                                 ++ #buf(32, 8)                               ++ #bufSeg(#buf(32, YY8), 24, 8) ++ #buf(24, 0)
;                                 ++ #buf(32, {SIGNATURE_LENGTH})              ++ #buf({SIGNATURE_LENGTH}, SIGNATURE)
;                                 ++ #buf(32, 8)                               ++ #bufSeg(#buf(32, Y8), 24, 8) ++ #buf(24, 0)
;                                 }) )

;    # Compute `DepositData` hash tree root
;    zero_bytes32: bytes32 = 0x0000000000000000000000000000000000000000000000000000000000000000
;    pubkey_root: bytes32 = sha256(concat(pubkey, slice(zero_bytes32, start=0, len=64 - PUBKEY_LENGTH)))
;    signature_root: bytes32 = sha256(concat(
;        sha256(slice(signature, start=0, len=64)),                                                             <-- tmp1
;        sha256(concat(slice(signature, start=64, len=SIGNATURE_LENGTH - 64), zero_bytes32)),                   <-- tmp2
;    ))
;    node: bytes32 = sha256(concat(
;        sha256(concat(pubkey_root, withdrawal_credentials)),                                                   <-- tmp3
;        sha256(concat(amount, slice(zero_bytes32, start=0, len=32 - AMOUNT_LENGTH), signature_root)),          <-- tmp4
;    ))
;    # Verify computed and expected deposit data roots match
;    assert node == deposit_data_root

; #### `DepositData`
;
; ```python
; class DepositData(Container):
;     pubkey: BLSPubkey
;     withdrawal_credentials: Hash
;     amount: Gwei
;     signature: BLSSignature
; ```

;                                    ___________________________ node _________________________
;                                   /                                                          \
;                    __________ tmp3 ___________________                        ______________ tmp4 _______________
;                   /                                   \                      /                                   \
;           pubkey_root                       withdrawal_credentials       amount                        _____ signature_root __________
;           /       \                                                                                   /                               \
;   pubkey[0:32]  pubkey[32:48]++zero[0:16]                                                           tmp1                             tmp2
;                                                                                                  /       \                        /        \
;                                                                                       signature[0:32]  signature[32:64]  signature[64:96]  zero[0:32]

[deposit-data]
pc: {PC_DATA} => {PC_ADD_BEGIN}
word_stack: .WordStack
local_mem: {LOCAL_MEM_LOG} => {LOCAL_MEM_DATA}
+CONDITIONS:
    // conditions
    andBool {NODE} ==Int DEPOSIT_DATA_ROOT
gas:         #symGas(G, 0 => {GAS_COST}, 0 => {GAS_COST}, .List, Cmem({SCHEDULE}, {MEMORY_USED}))
memory_used: #symMem({MU_LOG} => {MU_DATA}, .Set)
GAS_COST: 14376

[deposit-data-revert]
k: #execute => #halt
status_code: _ => EVMC_REVERT
pc: {PC_DATA} => 4086
word_stack: .WordStack => _
local_mem: {LOCAL_MEM_LOG} => _
CONDITIONS:
    // conditions
    andBool DEPOSIT_COUNT <Int {MAX_DEPOSIT_COUNT}
    andBool CALL_VALUE /Int {GWEI_IN_WEI} >=Int {MIN_DEPOSIT_AMOUNT}
    andBool {NODE} =/=Int DEPOSIT_DATA_ROOT
gas:         #symGas(G, 0 => {GAS_COST}, 0 => {GAS_COST}, .List, Cmem({SCHEDULE}, {MEMORY_USED}))
memory_used: #symMem({MU_LOG} => {MU_DATA}, .Set)
GAS_COST: 14381

;    # Add `DepositData` hash tree root to Merkle tree (update a single `branch` node)
;    self.deposit_count += 1
;    size: uint256 = self.deposit_count
;    for height in range(DEPOSIT_CONTRACT_TREE_DEPTH):
;        if bitwise_and(size, 1) == 1:  # More gas efficient than `size % 2 == 1`
;            self.branch[height] = node
;            break
;        node = sha256(concat(self.branch[height], node))
;        size /= 2

[deposit-add]
WORD_STACK_INIT: 32 : 3360 : .WordStack

[deposit-add-init]
;

[deposit-add-init-then]
k: #execute => #halt
output: _ => .WordStack
status_code: _ => EVMC_SUCCESS
pc: {PC_ADD_BEGIN} => {PC_ADD_END}
word_stack: .WordStack
local_mem: {LOCAL_MEM_DATA} => {LOCAL_MEM_DATA}
    [ 3328 := #buf(32, DEPOSIT_COUNT +Int 1) ]          /* size: uint256 = self.deposit_count */
    [ 3360 := #buf(32, 0) ]                             /* height */
    [  192 := #buf(32, 0) ]
storage: M => M
    [ #hashedLocation({COMPILER}, {DEPOSIT_COUNT}, .IntList) <- DEPOSIT_COUNT +Int 1 ]
    [ #hashedLocation({COMPILER}, {BRANCH}, 0)               <- {NODE} ]
refund: _ => _
+requires:
    // conditions
    andBool (DEPOSIT_COUNT +Int 1) &Int 1 ==Int 1
gas:         #symGas(G, 0 => 11019, 0 => 41019, .List, Cmem({SCHEDULE}, {MEMORY_USED}))
memory_used: #symMem({MU_DATA} => {MU_ADD_ODD}, .Set)

[deposit-add-init-else]
pc: {PC_ADD_BEGIN} => {PC_ADD_LOOPHEAD}
word_stack: .WordStack => 1 : {WORD_STACK_INIT}
local_mem: {LOCAL_MEM_DATA} => {LOCAL_MEM_DATA}
    [ 3328 := #buf(32, DEPOSIT_COUNT +Int 1) ]          /* size: uint256 = self.deposit_count */
    [ 3360 := #buf(32, 0) ]                             /* height */
    [  192 := #buf(32, 0) ]
    [ 3424 := #buf(32, {BRANCH_0}) ]
    [ 3456 := #buf(32, {NODE}) ]
    [ 3392 := #buf(32, 64) ]
    [  192 := #buf(32, {NODE_1}) ]                      /* sha256(3424, 64) */
    [ 2784 := #buf(32, {NODE_1}) ]                      /* node = sha256(concat(self.branch[height], node)) */
    [ 3328 := #buf(32, (DEPOSIT_COUNT +Int 1) /Int 2) ] /* update size */
    [ 3360 := #buf(32, 1) ]                             /* update height */
BRANCH_0: select(M, #hashedLocation({COMPILER}, {BRANCH}, 0))
NODE_1: #sha256(#buf(32, {BRANCH_0}) ++ #buf(32, {NODE}))
storage: M => M
    [ #hashedLocation({COMPILER}, {DEPOSIT_COUNT}, .IntList) <- DEPOSIT_COUNT +Int 1 ]
refund: _ => _
+requires:
    // conditions
    andBool (DEPOSIT_COUNT +Int 1) &Int 1 =/=Int 1
gas:         #symGas(G, 0 => 7196, 0 => 22196, .List, Cmem({SCHEDULE}, {MEMORY_USED}))
memory_used: #symMem({MU_DATA} => {MU_ADD_EVEN}, .Set)

[deposit-add-loop]
LOCAL_MEM_LOOPHEAD: {LOCAL_MEM_DATA}
    [ 3328 := #buf(32, SIZE) ]                      /* size */
    [ 3360 := #buf(32, HEIGHT) ]                    /* height */
    [  192 := #buf(32, 0) ]
    [ 3424 := #buf(32, ANON_1) ]
    [ 3456 := #buf(32, ANON_2) ]
    [ 3392 := #buf(32, 64) ]
    [  192 := #buf(32, NODE) ]                      /* sha256(3456, 64) */
    [ 2784 := #buf(32, NODE) ]                      /* node = sha256(concat(self.branch[height], node)) */
+requires:
    // conditions
    andBool #range(0 <= HEIGHT <= 32)
    // types
    andBool #rangeUInt(256, NODE)
    andBool #rangeUInt(256, SIZE)
    andBool #rangeUInt(256, ANON_1)
    andBool #rangeUInt(256, ANON_2)

[deposit-add-loop-enter]
+requires:
    // conditions
    andBool HEIGHT <Int 32

[deposit-add-loop-enter-then]
k: #execute => #halt
output: _ => .WordStack
status_code: _ => EVMC_SUCCESS
pc: {PC_ADD_LOOPHEAD} => {PC_ADD_END}
word_stack: HEIGHT : {WORD_STACK_INIT} => .WordStack
local_mem: {LOCAL_MEM_LOOPHEAD} => {LOCAL_MEM_LOOPHEAD}
    [  192 := #buf(32, 0) ]
storage: M => M
    [ #hashedLocation({COMPILER}, {BRANCH}, HEIGHT) <- NODE ]
refund: _ => _
+requires:
    // conditions
    andBool SIZE &Int 1 ==Int 1
gas:         #symGas(G, 0 => 5162, 0 => 20162, .List, Cmem({SCHEDULE}, {MEMORY_USED}))
memory_used: #symMem({MU_ADD_EVEN}, .Set)

[deposit-add-loop-enter-else]
pc: {PC_ADD_LOOPHEAD}
word_stack: (HEIGHT => HEIGHT +Int 1) : {WORD_STACK_INIT}
local_mem: {LOCAL_MEM_LOOPHEAD} => {LOCAL_MEM_LOOPHEAD}
    [  192 := #buf(32, 0) ]
    [ 3424 := #buf(32, {BRANCH_HEIGHT}) ]
    [ 3456 := #buf(32, NODE) ]
    [ 3392 := #buf(32, 64) ]
    [  192 := #buf(32, {NODE_NEW}) ]                    /* sha256(3456, 64) */
    [ 2784 := #buf(32, {NODE_NEW}) ]                    /* node = sha256(concat(self.branch[height], node)) */
    [ 3328 := #buf(32, SIZE /Int 2) ]                   /* update size */
    [ 3360 := #buf(32, HEIGHT +Int 1) ]                 /* update height */
BRANCH_HEIGHT: select(M, #hashedLocation({COMPILER}, {BRANCH}, HEIGHT))
NODE_NEW: #sha256(#buf(32, {BRANCH_HEIGHT}) ++ #buf(32, NODE))
+requires:
    // conditions
    andBool SIZE &Int 1 =/=Int 1
gas:         #symGas(G, 0 => {GAS_COST}, 0 => {GAS_COST}, .List, Cmem({SCHEDULE}, {MEMORY_USED}))
memory_used: #symMem({MU_ADD_EVEN}, .Set)
GAS_COST: 1339

[deposit-add-loop-exit]
k: #execute => #halt
output: _ => .WordStack
status_code: _ => EVMC_SUCCESS
pc: {PC_ADD_LOOPHEAD} => {PC_ADD_END}
word_stack: HEIGHT : {WORD_STACK_INIT} => .WordStack
local_mem: {LOCAL_MEM_LOOPHEAD}
+requires:
    // conditions
    andBool HEIGHT ==Int 32
gas:         #symGas(G, 0 => {GAS_COST}, 0 => {GAS_COST}, .List, Cmem({SCHEDULE}, {MEMORY_USED}))
memory_used: #symMem({MU_ADD_EVEN}, .Set)
GAS_COST: 27

;
; revert cases
;

[revert]
k: #execute => #halt
status_code: _ => EVMC_REVERT

; Revert if the first four bytes are invalid (or not fully provided).
[revert-invalid_function_identifier]
call_data: #buf(CALL_DATA_SIZE, CALL_DATA)
pc: 0 => 4345
gas:         #symGas(G, 0 => {GAS_COST}, 0 => {GAS_COST}, .List, Cmem({SCHEDULE}, {MEMORY_USED}))
memory_used: #symMem(0 => {MEM_COST}, .Set)

[revert-invalid_function_identifier-lt_4]
+requires:
    // conditions
    andBool #range(0 <= CALL_DATA_SIZE < 4)
;   andBool #asWord(#buf(CALL_DATA_SIZE, CALL_DATA) ++ #buf(4 -Int CALL_DATA_SIZE, 0)) =/=Int 3321006383 /* 0xc5f2892f get_deposit_root */
;   andBool #asWord(#buf(CALL_DATA_SIZE, CALL_DATA) ++ #buf(4 -Int CALL_DATA_SIZE, 0)) =/=Int 1646252336 /* 0x621fd130 get_deposit_count  */
;   andBool #asWord(#buf(CALL_DATA_SIZE, CALL_DATA) ++ #buf(4 -Int CALL_DATA_SIZE, 0)) =/=Int 579424536  /* 0x22895118 deposit            */
GAS_COST: 42
MEM_COST: 0

[revert-invalid_function_identifier-ge_4]
+requires:
    // conditions
    andBool #asWord(#bufSeg(#buf(CALL_DATA_SIZE, CALL_DATA), 0, 4)) =/=Int 3321006383 /* 0xc5f2892f get_deposit_root */
    andBool #asWord(#bufSeg(#buf(CALL_DATA_SIZE, CALL_DATA), 0, 4)) =/=Int 1646252336 /* 0x621fd130 get_deposit_count  */
    andBool #asWord(#bufSeg(#buf(CALL_DATA_SIZE, CALL_DATA), 0, 4)) =/=Int 579424536  /* 0x22895118 deposit            */
GAS_COST: 196
MEM_COST: 192

[revert-invalid_function_identifier-ge_4-lt_32]
+requires:
    // conditions
    andBool #range(4 <= CALL_DATA_SIZE < 32)

[revert-invalid_function_identifier-ge_4-ge_32]
+requires:
    // conditions
    andBool CALL_DATA_SIZE >=Int 32

[revert-init]
code: {INIT_CODE}
pc: 0 => 151
+requires:
    // conditions
    andBool CALL_VALUE =/=Int 0
gas:         #symGas(G, 0 => 69, 0 => 69, .List, Cmem({SCHEDULE}, {MEMORY_USED}))
memory_used: #symMem(0 => 192, .Set)

[revert-get_deposit_root]
call_data: #abiCallData("get_deposit_root", .TypedArgs) ++ #buf(EXTRA_CALL_DATA_SIZE, EXTRA_CALL_DATA)
pc: 0 => 670
+requires:
    // conditions
    andBool CALL_VALUE =/=Int 0
gas:         #symGas(G, 0 => {GAS_COST}, 0 => {GAS_COST}, .List, Cmem({SCHEDULE}, {MEMORY_USED}))
memory_used: #symMem(0 => 192, .Set)
GAS_COST: 154

[revert-get_deposit_count]
call_data: #abiCallData("get_deposit_count", .TypedArgs) ++ #buf(EXTRA_CALL_DATA_SIZE, EXTRA_CALL_DATA)
pc: 0 => 1328
+requires:
    // conditions
    andBool CALL_VALUE =/=Int 0
gas:         #symGas(G, 0 => {GAS_COST}, 0 => {GAS_COST}, .List, Cmem({SCHEDULE}, {MEMORY_USED}))
memory_used: #symMem(0 => 192, .Set)
GAS_COST: 183

;
; globals
;

[pgm]
COMPILER: "Array"
; Storage variables:
; branch: bytes32[DEPOSIT_CONTRACT_TREE_DEPTH]
; deposit_count: uint256
; zero_hashes: bytes32[DEPOSIT_CONTRACT_TREE_DEPTH]
BRANCH: 0
DEPOSIT_COUNT: 1
ZERO_HASHES: 2
; Constants:
; MIN_DEPOSIT_AMOUNT: constant(uint256) = 1000000000  # Gwei
; DEPOSIT_CONTRACT_TREE_DEPTH: constant(uint256) = 32
; MAX_DEPOSIT_COUNT: constant(uint256) = 4294967295 # 2**DEPOSIT_CONTRACT_TREE_DEPTH - 1
; PUBKEY_LENGTH: constant(uint256) = 48  # bytes
; WITHDRAWAL_CREDENTIALS_LENGTH: constant(uint256) = 32  # bytes
; AMOUNT_LENGTH: constant(uint256) = 8  # bytes
; SIGNATURE_LENGTH: constant(uint256) = 96  # bytes
DEPOSIT_CONTRACT_TREE_DEPTH: 32
; bytecode
RUNTIME_CODE: "0x600436101561000d576110f4565b600035601c52740100000000000000000000000000000000000000006020526f7fffffffffffffffffffffffffffffff6040527fffffffffffffffffffffffffffffffff8000000000000000000000000000000060605274012a05f1fffffffffffffffffffffffffdabf41c006080527ffffffffffffffffffffffffed5fa0e000000000000000000000000000000000060a052600015610286575b6101605261014052600061018052610140516101a0526101c060006008818352015b61018051600860008112156100e8578060000360020a82046100ef565b8060020a82025b905090506101805260ff6101a051166101e052610180516101e0516101805101101561011a57600080fd5b6101e0516101805101610180526101a0517ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff86000811215610163578060000360020a820461016a565b8060020a82025b905090506101a0525b81516001018083528114156100cb575b5050601860086020820661020001602082840111156101a157600080fd5b60208061022082610180600060046015f15050818152809050905090508051602001806102c0828460006004600a8704601201f16101de57600080fd5b50506102c05160206001820306601f82010390506103206102c0516020818352015b82610320511015156102115761022d565b6000610320516102e001535b8151600101808352811415610200575b50505060206102a05260406102c0510160206001820306601f8201039050610280525b6000610280511115156102625761027e565b602061028051036102a001516020610280510361028052610250565b610160515650005b63c5f2892f600051141561051857341561029f57600080fd5b6000610140526101405161016052600154610180526101a060006020818352015b60016001610180511614156103415760006101a051602081106102e257600080fd5b600060c052602060c02001546020826102400101526020810190506101605160208261024001015260208101905080610240526102409050602060c0825160208401600060025af161033357600080fd5b60c0519050610160526103af565b6000610160516020826101c00101526020810190506101a0516020811061036757600080fd5b600260c052602060c02001546020826101c0010152602081019050806101c0526101c09050602060c0825160208401600060025af16103a557600080fd5b60c0519050610160525b61018060026103bd57600080fd5b60028151048152505b81516001018083528114156102c0575b505060006101605160208261046001015260208101905061014051610160516101805163806732896102e0526001546103005261030051600658016100a9565b506103605260006103c0525b6103605160206001820306601f82010390506103c0511015156104445761045d565b6103c05161038001526103c0516020016103c052610422565b61018052610160526101405261036060088060208461046001018260208501600060046012f150508051820191505060006018602082066103e001602082840111156104a857600080fd5b60208061040082610140600060046015f150508181528090509050905060188060208461046001018260208501600060046014f150508051820191505080610460526104609050602060c0825160208401600060025af161050857600080fd5b60c051905060005260206000f350005b63621fd130600051141561062c57341561053157600080fd5b6380673289610140526001546101605261016051600658016100a9565b506101c0526000610220525b6101c05160206001820306601f82010390506102205110151561057c57610595565b610220516101e00152610220516020016102205261055a565b6101c0805160200180610280828460006004600a8704601201f16105b857600080fd5b50506102805160206001820306601f82010390506102e0610280516020818352015b826102e0511015156105eb57610607565b60006102e0516102a001535b81516001018083528114156105da575b5050506020610260526040610280510160206001820306601f8201039050610260f350005b632289511860005114156110f357605060043560040161014037603060043560040135111561065a57600080fd5b60406024356004016101c037602060243560040135111561067a57600080fd5b608060443560040161022037606060443560040135111561069a57600080fd5b63ffffffff600154106106ac57600080fd5b633b9aca006102e0526102e0516106c257600080fd5b6102e05134046102c052633b9aca006102c05110156106e057600080fd5b603061014051146106f057600080fd5b60206101c0511461070057600080fd5b6060610220511461071057600080fd5b610140610360525b6103605151602061036051016103605261036061036051101561073a57610718565b6380673289610380526102c0516103a0526103a051600658016100a9565b50610400526000610460525b6104005160206001820306601f8201039050610460511015156107865761079f565b6104605161042001526104605160200161046052610764565b610340610360525b61036051526020610360510361036052610140610360511015156107ca576107a7565b610400805160200180610300828460006004600a8704601201f16107ed57600080fd5b5050610140610480525b61048051516020610480510161048052610480610480511015610819576107f7565b63806732896104a0526001546104c0526104c051600658016100a9565b50610520526000610580525b6105205160206001820306601f8201039050610580511015156108645761087d565b6105805161054001526105805160200161058052610842565b610460610480525b61048051526020610480510361048052610140610480511015156108a857610885565b6105208051602001806105a0828460006004600a8704601201f16108cb57600080fd5b505060a06106205261062051610660526101408051602001806106205161066001828460006004600a8704601201f161090357600080fd5b505061062051610660015160206001820306601f82010390506106006106205161066001516040818352015b826106005110151561094057610961565b600061060051610620516106800101535b815160010180835281141561092f575b505050602061062051610660015160206001820306601f82010390506106205101016106205261062051610680526101c08051602001806106205161066001828460006004600a8704601201f16109b757600080fd5b505061062051610660015160206001820306601f82010390506106006106205161066001516020818352015b82610600511015156109f457610a15565b600061060051610620516106800101535b81516001018083528114156109e3575b505050602061062051610660015160206001820306601f820103905061062051010161062052610620516106a0526103008051602001806106205161066001828460006004600a8704601201f1610a6b57600080fd5b505061062051610660015160206001820306601f82010390506106006106205161066001516020818352015b8261060051101515610aa857610ac9565b600061060051610620516106800101535b8151600101808352811415610a97575b505050602061062051610660015160206001820306601f820103905061062051010161062052610620516106c0526102208051602001806106205161066001828460006004600a8704601201f1610b1f57600080fd5b505061062051610660015160206001820306601f82010390506106006106205161066001516060818352015b8261060051101515610b5c57610b7d565b600061060051610620516106800101535b8151600101808352811415610b4b575b505050602061062051610660015160206001820306601f820103905061062051010161062052610620516106e0526105a08051602001806106205161066001828460006004600a8704601201f1610bd357600080fd5b505061062051610660015160206001820306601f82010390506106006106205161066001516020818352015b8261060051101515610c1057610c31565b600061060051610620516106800101535b8151600101808352811415610bff575b505050602061062051610660015160206001820306601f8201039050610620510101610620527f649bbc62d0e31342afea4e5cd82d4049e7e1ee912fc0889aa790803be39038c561062051610660a160006107005260006101406030806020846107c001018260208501600060046016f150508051820191505060006010602082066107400160208284011115610cc757600080fd5b60208061076082610700600060046015f15050818152809050905090506010806020846107c001018260208501600060046013f1505080518201915050806107c0526107c09050602060c0825160208401600060025af1610d2757600080fd5b60c0519050610720526000600060406020820661086001610220518284011115610d5057600080fd5b606080610880826020602088068803016102200160006004601bf1505081815280905090509050602060c0825160208401600060025af1610d9057600080fd5b60c0519050602082610a600101526020810190506000604060206020820661092001610220518284011115610dc457600080fd5b606080610940826020602088068803016102200160006004601bf15050818152809050905090506020806020846109e001018260208501600060046015f1505080518201915050610700516020826109e0010152602081019050806109e0526109e09050602060c0825160208401600060025af1610e4157600080fd5b60c0519050602082610a6001015260208101905080610a6052610a609050602060c0825160208401600060025af1610e7857600080fd5b60c0519050610840526000600061072051602082610b000101526020810190506101c0602080602084610b0001018260208501600060046015f150508051820191505080610b0052610b009050602060c0825160208401600060025af1610ede57600080fd5b60c0519050602082610c800101526020810190506000610300600880602084610c0001018260208501600060046012f15050805182019150506000601860208206610b800160208284011115610f3357600080fd5b602080610ba082610700600060046015f1505081815280905090509050601880602084610c0001018260208501600060046014f150508051820191505061084051602082610c0001015260208101905080610c0052610c009050602060c0825160208401600060025af1610fa657600080fd5b60c0519050602082610c8001015260208101905080610c8052610c809050602060c0825160208401600060025af1610fdd57600080fd5b60c0519050610ae052606435610ae05114610ff757600080fd5b600180546001825401101561100b57600080fd5b6001815401815550600154610d0052610d2060006020818352015b60016001610d005116141561105b57610ae051610d20516020811061104a57600080fd5b600060c052602060c02001556110ef565b6000610d20516020811061106e57600080fd5b600060c052602060c0200154602082610d40010152602081019050610ae051602082610d4001015260208101905080610d4052610d409050602060c0825160208401600060025af16110bf57600080fd5b60c0519050610ae052610d0060026110d657600080fd5b60028151048152505b8151600101808352811415611026575b5050005b5b60006000fd"
INIT_CODE: "0x740100000000000000000000000000000000000000006020526f7fffffffffffffffffffffffffffffff6040527fffffffffffffffffffffffffffffffff8000000000000000000000000000000060605274012a05f1fffffffffffffffffffffffffdabf41c006080527ffffffffffffffffffffffffed5fa0e000000000000000000000000000000000060a052341561009857600080fd5b6101406000601f818352015b600061014051602081106100b757600080fd5b600260c052602060c020015460208261016001015260208101905061014051602081106100e357600080fd5b600260c052602060c020015460208261016001015260208101905080610160526101609050602060c0825160208401600060025af161012157600080fd5b60c0519050606051600161014051018060405190131561014057600080fd5b809190121561014e57600080fd5b6020811061015b57600080fd5b600260c052602060c02001555b81516001018083528114156100a4575b505061127956600436101561000d576110f4565b600035601c52740100000000000000000000000000000000000000006020526f7fffffffffffffffffffffffffffffff6040527fffffffffffffffffffffffffffffffff8000000000000000000000000000000060605274012a05f1fffffffffffffffffffffffffdabf41c006080527ffffffffffffffffffffffffed5fa0e000000000000000000000000000000000060a052600015610286575b6101605261014052600061018052610140516101a0526101c060006008818352015b61018051600860008112156100e8578060000360020a82046100ef565b8060020a82025b905090506101805260ff6101a051166101e052610180516101e0516101805101101561011a57600080fd5b6101e0516101805101610180526101a0517ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff86000811215610163578060000360020a820461016a565b8060020a82025b905090506101a0525b81516001018083528114156100cb575b5050601860086020820661020001602082840111156101a157600080fd5b60208061022082610180600060046015f15050818152809050905090508051602001806102c0828460006004600a8704601201f16101de57600080fd5b50506102c05160206001820306601f82010390506103206102c0516020818352015b82610320511015156102115761022d565b6000610320516102e001535b8151600101808352811415610200575b50505060206102a05260406102c0510160206001820306601f8201039050610280525b6000610280511115156102625761027e565b602061028051036102a001516020610280510361028052610250565b610160515650005b63c5f2892f600051141561051857341561029f57600080fd5b6000610140526101405161016052600154610180526101a060006020818352015b60016001610180511614156103415760006101a051602081106102e257600080fd5b600060c052602060c02001546020826102400101526020810190506101605160208261024001015260208101905080610240526102409050602060c0825160208401600060025af161033357600080fd5b60c0519050610160526103af565b6000610160516020826101c00101526020810190506101a0516020811061036757600080fd5b600260c052602060c02001546020826101c0010152602081019050806101c0526101c09050602060c0825160208401600060025af16103a557600080fd5b60c0519050610160525b61018060026103bd57600080fd5b60028151048152505b81516001018083528114156102c0575b505060006101605160208261046001015260208101905061014051610160516101805163806732896102e0526001546103005261030051600658016100a9565b506103605260006103c0525b6103605160206001820306601f82010390506103c0511015156104445761045d565b6103c05161038001526103c0516020016103c052610422565b61018052610160526101405261036060088060208461046001018260208501600060046012f150508051820191505060006018602082066103e001602082840111156104a857600080fd5b60208061040082610140600060046015f150508181528090509050905060188060208461046001018260208501600060046014f150508051820191505080610460526104609050602060c0825160208401600060025af161050857600080fd5b60c051905060005260206000f350005b63621fd130600051141561062c57341561053157600080fd5b6380673289610140526001546101605261016051600658016100a9565b506101c0526000610220525b6101c05160206001820306601f82010390506102205110151561057c57610595565b610220516101e00152610220516020016102205261055a565b6101c0805160200180610280828460006004600a8704601201f16105b857600080fd5b50506102805160206001820306601f82010390506102e0610280516020818352015b826102e0511015156105eb57610607565b60006102e0516102a001535b81516001018083528114156105da575b5050506020610260526040610280510160206001820306601f8201039050610260f350005b632289511860005114156110f357605060043560040161014037603060043560040135111561065a57600080fd5b60406024356004016101c037602060243560040135111561067a57600080fd5b608060443560040161022037606060443560040135111561069a57600080fd5b63ffffffff600154106106ac57600080fd5b633b9aca006102e0526102e0516106c257600080fd5b6102e05134046102c052633b9aca006102c05110156106e057600080fd5b603061014051146106f057600080fd5b60206101c0511461070057600080fd5b6060610220511461071057600080fd5b610140610360525b6103605151602061036051016103605261036061036051101561073a57610718565b6380673289610380526102c0516103a0526103a051600658016100a9565b50610400526000610460525b6104005160206001820306601f8201039050610460511015156107865761079f565b6104605161042001526104605160200161046052610764565b610340610360525b61036051526020610360510361036052610140610360511015156107ca576107a7565b610400805160200180610300828460006004600a8704601201f16107ed57600080fd5b5050610140610480525b61048051516020610480510161048052610480610480511015610819576107f7565b63806732896104a0526001546104c0526104c051600658016100a9565b50610520526000610580525b6105205160206001820306601f8201039050610580511015156108645761087d565b6105805161054001526105805160200161058052610842565b610460610480525b61048051526020610480510361048052610140610480511015156108a857610885565b6105208051602001806105a0828460006004600a8704601201f16108cb57600080fd5b505060a06106205261062051610660526101408051602001806106205161066001828460006004600a8704601201f161090357600080fd5b505061062051610660015160206001820306601f82010390506106006106205161066001516040818352015b826106005110151561094057610961565b600061060051610620516106800101535b815160010180835281141561092f575b505050602061062051610660015160206001820306601f82010390506106205101016106205261062051610680526101c08051602001806106205161066001828460006004600a8704601201f16109b757600080fd5b505061062051610660015160206001820306601f82010390506106006106205161066001516020818352015b82610600511015156109f457610a15565b600061060051610620516106800101535b81516001018083528114156109e3575b505050602061062051610660015160206001820306601f820103905061062051010161062052610620516106a0526103008051602001806106205161066001828460006004600a8704601201f1610a6b57600080fd5b505061062051610660015160206001820306601f82010390506106006106205161066001516020818352015b8261060051101515610aa857610ac9565b600061060051610620516106800101535b8151600101808352811415610a97575b505050602061062051610660015160206001820306601f820103905061062051010161062052610620516106c0526102208051602001806106205161066001828460006004600a8704601201f1610b1f57600080fd5b505061062051610660015160206001820306601f82010390506106006106205161066001516060818352015b8261060051101515610b5c57610b7d565b600061060051610620516106800101535b8151600101808352811415610b4b575b505050602061062051610660015160206001820306601f820103905061062051010161062052610620516106e0526105a08051602001806106205161066001828460006004600a8704601201f1610bd357600080fd5b505061062051610660015160206001820306601f82010390506106006106205161066001516020818352015b8261060051101515610c1057610c31565b600061060051610620516106800101535b8151600101808352811415610bff575b505050602061062051610660015160206001820306601f8201039050610620510101610620527f649bbc62d0e31342afea4e5cd82d4049e7e1ee912fc0889aa790803be39038c561062051610660a160006107005260006101406030806020846107c001018260208501600060046016f150508051820191505060006010602082066107400160208284011115610cc757600080fd5b60208061076082610700600060046015f15050818152809050905090506010806020846107c001018260208501600060046013f1505080518201915050806107c0526107c09050602060c0825160208401600060025af1610d2757600080fd5b60c0519050610720526000600060406020820661086001610220518284011115610d5057600080fd5b606080610880826020602088068803016102200160006004601bf1505081815280905090509050602060c0825160208401600060025af1610d9057600080fd5b60c0519050602082610a600101526020810190506000604060206020820661092001610220518284011115610dc457600080fd5b606080610940826020602088068803016102200160006004601bf15050818152809050905090506020806020846109e001018260208501600060046015f1505080518201915050610700516020826109e0010152602081019050806109e0526109e09050602060c0825160208401600060025af1610e4157600080fd5b60c0519050602082610a6001015260208101905080610a6052610a609050602060c0825160208401600060025af1610e7857600080fd5b60c0519050610840526000600061072051602082610b000101526020810190506101c0602080602084610b0001018260208501600060046015f150508051820191505080610b0052610b009050602060c0825160208401600060025af1610ede57600080fd5b60c0519050602082610c800101526020810190506000610300600880602084610c0001018260208501600060046012f15050805182019150506000601860208206610b800160208284011115610f3357600080fd5b602080610ba082610700600060046015f1505081815280905090509050601880602084610c0001018260208501600060046014f150508051820191505061084051602082610c0001015260208101905080610c0052610c009050602060c0825160208401600060025af1610fa657600080fd5b60c0519050602082610c8001015260208101905080610c8052610c809050602060c0825160208401600060025af1610fdd57600080fd5b60c0519050610ae052606435610ae05114610ff757600080fd5b600180546001825401101561100b57600080fd5b6001815401815550600154610d0052610d2060006020818352015b60016001610d005116141561105b57610ae051610d20516020811061104a57600080fd5b600060c052602060c02001556110ef565b6000610d20516020811061106e57600080fd5b600060c052602060c0200154602082610d40010152602081019050610ae051602082610d4001015260208101905080610d4052610d409050602060c0825160208401600060025af16110bf57600080fd5b60c0519050610ae052610d0060026110d657600080fd5b60028151048152505b8151600101808352811415611026575b5050005b5b60006000fd5b61017f6112790361017f60003961017f611279036000f3"
