# Converts hex numbers in the file generated by solc --asm <file>, into decimal.
# Required to correlate solc asm format with program pretty-printed by kprove,
# which contains only decimal numbers.
# Also formats opcodes in a way more compatible with KEVM <program> content.

# Adapted from:
# https://codereview.stackexchange.com/questions/152752/read-hex-from-file-and-convert-to-decimal

# Usage: hex_to_decimal.py <input file>
# It generates an output file in the same directory.

import argparse
import os

opcodes = {
    'stop'          : 'STOP',
    'add'           : 'ADD',
    'mul'           : 'MUL',
    'sub'           : 'SUB',
    'div'           : 'DIV',
    'sdiv'          : 'SDIV',
    'mod'           : 'MOD',
    'smod'          : 'SMOD',
    'addmod'        : 'ADDMOD',
    'mulmod'        : 'MULMOD',
    'exp'           : 'EXP',
    'signextend'    : 'SIGNEXTEND',
    'lt'            : 'LT',
    'gt'            : 'GT',
    'slt'           : 'SLT',
    'sgt'           : 'SGT',
    'eq'            : 'EQ',
    'iszero'        : 'ISZERO',
    'and'           : 'AND',
    'or'            : 'OR', 'evmor' : 'EVMOR',
    'xor'           : 'XOR',
    'not'           : 'NOT',
    'byte'          : 'BYTE',
    'sha3'          : 'SHA3',
    'address'       : 'ADDRESS',
    'balance'       : 'BALANCE',
    'origin'        : 'ORIGIN',
    'caller'        : 'CALLER',
    'callvalue'     : 'CALLVALUE',
    'calldataload'  : 'CALLDATALOAD',
    'calldatasize'  : 'CALLDATASIZE',
    'calldatacopy'  : 'CALLDATACOPY',
    'codesize'      : 'CODESIZE',
    'codecopy'      : 'CODECOPY',
    'gasprice'      : 'GASPRICE',
    'extcodesize'   : 'EXTCODESIZE',
    'extcodecopy'   : 'EXTCODECOPY',
    'blockhash'     : 'BLOCKHASH',
    'coinbase'      : 'COINBASE',
    'timestamp'     : 'TIMESTAMP',
    'number'        : 'NUMBER',
    'difficulty'    : 'DIFFICULTY',
    'gaslimit'      : 'GASLIMIT',
    'pop'           : 'POP',
    'mload'         : 'MLOAD',
    'mstore'        : 'MSTORE',
    'mstore8'       : 'MSTORE8',
    'sload'         : 'SLOAD',
    'sstore'        : 'SSTORE',
    'jump'          : 'JUMP',
    'jumpi'         : 'JUMPI',
    'pc'            : 'PC',
    'msize'         : 'MSIZE',
    'gas'           : 'GAS',
    'jumpdest'      : 'JUMPDEST',
    'push1'         : 'PUSH1',
    'push2'         : 'PUSH2',
    'push3'         : 'PUSH3',
    'push4'         : 'PUSH4',
    'push5'         : 'PUSH5',
    'push6'         : 'PUSH6',
    'push7'         : 'PUSH7',
    'push8'         : 'PUSH8',
    'push9'         : 'PUSH9',
    'push10'        : 'PUSH10',
    'push11'        : 'PUSH11',
    'push12'        : 'PUSH12',
    'push13'        : 'PUSH13',
    'push14'        : 'PUSH14',
    'push15'        : 'PUSH15',
    'push16'        : 'PUSH16',
    'push17'        : 'PUSH17',
    'push18'        : 'PUSH18',
    'push19'        : 'PUSH19',
    'push20'        : 'PUSH20',
    'push21'        : 'PUSH21',
    'push22'        : 'PUSH22',
    'push23'        : 'PUSH23',
    'push24'        : 'PUSH24',
    'push25'        : 'PUSH25',
    'push26'        : 'PUSH26',
    'push27'        : 'PUSH27',
    'push28'        : 'PUSH28',
    'push29'        : 'PUSH29',
    'push30'        : 'PUSH30',
    'push31'        : 'PUSH31',
    'push32'        : 'PUSH32',
    'dup1'          : 'DUP ( 1 )',
    'dup2'          : 'DUP ( 2 )',
    'dup3'          : 'DUP ( 3 )',
    'dup4'          : 'DUP ( 4 )',
    'dup5'          : 'DUP ( 5 )',
    'dup6'          : 'DUP ( 6 )',
    'dup7'          : 'DUP ( 7 )',
    'dup8'          : 'DUP ( 8 )',
    'dup9'          : 'DUP ( 9 )',
    'dup10'         : 'DUP ( 10 )',
    'dup11'         : 'DUP ( 11 )',
    'dup12'         : 'DUP ( 12 )',
    'dup13'         : 'DUP ( 13 )',
    'dup14'         : 'DUP ( 14 )',
    'dup15'         : 'DUP ( 15 )',
    'dup16'         : 'DUP ( 16 )',
    'swap1'         : 'SWAP ( 1 )',
    'swap2'         : 'SWAP ( 2 )',
    'swap3'         : 'SWAP ( 3 )',
    'swap4'         : 'SWAP ( 4 )',
    'swap5'         : 'SWAP ( 5 )',
    'swap6'         : 'SWAP ( 6 )',
    'swap7'         : 'SWAP ( 7 )',
    'swap8'         : 'SWAP ( 8 )',
    'swap9'         : 'SWAP ( 9 )',
    'swap10'        : 'SWAP ( 10 )',
    'swap11'        : 'SWAP ( 11 )',
    'swap12'        : 'SWAP ( 12 )',
    'swap13'        : 'SWAP ( 13 )',
    'swap14'        : 'SWAP ( 14 )',
    'swap15'        : 'SWAP ( 15 )',
    'swap16'        : 'SWAP ( 16 )',
    'log0'          : 'LOG ( 0 )',
    'log1'          : 'LOG ( 1 )',
    'log2'          : 'LOG ( 2 )',
    'log3'          : 'LOG ( 3 )',
    'log4'          : 'LOG ( 4 )',
    'create'        : 'CREATE',
    'call'          : 'CALL',
    'callcode'      : 'CALLCODE',
    'return'        : 'RETURN',
    'delegatecall'  : 'DELEGATECALL',
    'callblackbox'  : 'CALLBLACKBOX',
    'staticcall'    : 'STATICCALL',
    'revert'        : 'REVERT',
    'invalid'       : 'INVALID',
    'suicide'       : 'SUICIDE',
    'selfdestruct'  : 'SELFDESTRUCT',
}

# Limitation: out file should have an extension of 3 characters, like ".txt"
def write_and_print_result(args, result):
    """Write every result to the output file
    and print each converted value
    """
    out_file = args['input_file'][:-4] + "_converted.sol"
    with open(out_file, 'w') as output:
        for converted in result:
            output.write(converted)


def read_and_convert_file(args):
    """Read the given input file and convert each hexadecimal value
    to decimal value
    """
    result = []
    with open(args['input_file']) as input_file:
        for line in input_file:
            # move trailing whitespaces to another string
            cleaned_line = line.lstrip()  # removed trailing whitespaces
            trimmed_line=cleaned_line.strip()
            nr_spaces = len(line) - len(cleaned_line)
            spaces = line[0:nr_spaces]

            if cleaned_line.startswith('0x'):   # convert hex values
                result.append(spaces + str(int(cleaned_line, 0)) + "\n")
            elif trimmed_line in opcodes:       # convert opcodes
                result.append(spaces + opcodes[trimmed_line] + "\n")
            elif trimmed_line.find("(") != -1:
                parenthese_pos = trimmed_line.find("(")
                opcode = trimmed_line[:parenthese_pos]
                rest = trimmed_line[parenthese_pos:]
                if opcode in opcodes:
                    result.append(spaces + opcodes[opcode] + rest + "\n")
                else:
                    result.append(line)
            else:
                result.append(line)
    return result


def cli_runner():
    parser = argparse.ArgumentParser()
    parser.add_argument('input_file', type=str,
                        help='The file to read the hexadecimal values from')
    args = vars(parser.parse_args())

    if not os.path.exists(args['input_file']):
        print('Input file does not exist, please try again.')
        return

    result = read_and_convert_file(args)
    write_and_print_result(args, result)


if __name__ == '__main__':
    cli_runner()
